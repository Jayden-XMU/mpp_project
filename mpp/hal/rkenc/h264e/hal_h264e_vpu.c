/*
 * Copyright 2015 Rockchip Electronics Co. LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define MODULE_TAG "hal_h264e_vpu"
#include <string.h>
#include "vpu.h"
#include "rk_mpi.h"
#include "mpp_mem.h"
#include "mpp_frame.h"
#include "hal_h264e.h"
#include "hal_h264e_vpu.h"


/* H.264 motion estimation parameters */
static const RK_U32 h264_prev_mode_favor[52] = {
    7, 7, 8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 24, 25, 27, 29, 30, 32, 34, 36, 38, 41, 43, 46,
    49, 51, 55, 58, 61, 65, 69, 73, 78, 82, 87, 93, 98, 104, 110,
    117, 124, 132, 140
};

/* sqrt(2^((qp-12)/3))*8 */
static const RK_U32 h264_diff_mv_penalty[52] = {
    2, 2, 3, 3, 3, 4, 4, 4, 5, 6,
    6, 7, 8, 9, 10, 11, 13, 14, 16, 18,
    20, 23, 26, 29, 32, 36, 40, 45, 51, 57,
    64, 72, 81, 91, 102, 114, 128, 144, 161, 181,
    203, 228, 256, 287, 323, 362, 406, 456, 512, 575,
    645, 724
};

/* 31*sqrt(2^((qp-12)/3))/4 */
static const RK_U32 h264_diff_mv_penalty4p[52] = {
    2, 2, 2, 3, 3, 3, 4, 4, 5, 5,
    6, 7, 8, 9, 10, 11, 12, 14, 16, 17,
    20, 22, 25, 28, 31, 35, 39, 44, 49, 55,
    62, 70, 78, 88, 98, 110, 124, 139, 156, 175,
    197, 221, 248, 278, 312, 351, 394, 442, 496, 557,
    625, 701
};

static const RK_U32 h264_intra16_favor[52] = {
    24, 24, 24, 26, 27, 30, 32, 35, 39, 43, 48, 53, 58, 64, 71, 78,
    85, 93, 102, 111, 121, 131, 142, 154, 167, 180, 195, 211, 229,
    248, 271, 296, 326, 361, 404, 457, 523, 607, 714, 852, 1034,
    1272, 1588, 2008, 2568, 3318, 4323, 5672, 7486, 9928, 13216,
    17648
};

static const RK_U32 h264_inter_favor[52] = {
    40, 40, 41, 42, 43, 44, 45, 48, 51, 53, 55, 60, 62, 67, 69, 72,
    78, 84, 90, 96, 110, 120, 135, 152, 170, 189, 210, 235, 265,
    297, 335, 376, 420, 470, 522, 572, 620, 670, 724, 770, 820,
    867, 915, 970, 1020, 1076, 1132, 1180, 1230, 1275, 1320, 1370
};

static RK_U32 h264_skip_sad_penalty[52] = {
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 233, 205, 182, 163,
    146, 132, 120, 109, 100,  92,  84,  78,  71,  66,  61,  56,  52,  48,
    44,  41,  38,  35,  32,  30,  27,  25,  23,  21,  19,  17,  15,  14,
    12,  11,   9,   8,   7,   5,   4,   3,   2,   1
};

const RK_S32 h264_context_init_intra[460][2] = {
    /* 0 -> 10 */
    { 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
    { 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
    { -6, 53 }, { -1, 54 }, { 7, 51 },

    /* 11 -> 23 unsused for I */
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 },

    /* 24 -> 39 */
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },

    /* 40 -> 53 */
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 },

    /* 54 -> 59 */
    { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
    { 0, 0 }, { 0, 0 },

    /* 60 -> 69 */
    { 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
    { -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
    { 13, 41 }, { 3, 62 },

    /* 70 -> 87 */
    { 0, 11 }, { 1, 55 }, { 0, 69 }, { -17, 127 },
    { -13, 102 }, { 0, 82 }, { -7, 74 }, { -21, 107 },
    { -27, 127 }, { -31, 127 }, { -24, 127 }, { -18, 95 },
    { -27, 127 }, { -21, 114 }, { -30, 127 }, { -17, 123 },
    { -12, 115 }, { -16, 122 },

    /* 88 -> 104 */
    { -11, 115 }, { -12, 63 }, { -2, 68 }, { -15, 84 },
    { -13, 104 }, { -3, 70 }, { -8, 93 }, { -10, 90 },
    { -30, 127 }, { -1, 74 }, { -6, 97 }, { -7, 91 },
    { -20, 127 }, { -4, 56 }, { -5, 82 }, { -7, 76 },
    { -22, 125 },

    /* 105 -> 135 */
    { -7, 93 }, { -11, 87 }, { -3, 77 }, { -5, 71 },
    { -4, 63 }, { -4, 68 }, { -12, 84 }, { -7, 62 },
    { -7, 65 }, { 8, 61 }, { 5, 56 }, { -2, 66 },
    { 1, 64 }, { 0, 61 }, { -2, 78 }, { 1, 50 },
    { 7, 52 }, { 10, 35 }, { 0, 44 }, { 11, 38 },
    { 1, 45 }, { 0, 46 }, { 5, 44 }, { 31, 17 },
    { 1, 51 }, { 7, 50 }, { 28, 19 }, { 16, 33 },
    { 14, 62 }, { -13, 108 }, { -15, 100 },

    /* 136 -> 165 */
    { -13, 101 }, { -13, 91 }, { -12, 94 }, { -10, 88 },
    { -16, 84 }, { -10, 86 }, { -7, 83 }, { -13, 87 },
    { -19, 94 }, { 1, 70 }, { 0, 72 }, { -5, 74 },
    { 18, 59 }, { -8, 102 }, { -15, 100 }, { 0, 95 },
    { -4, 75 }, { 2, 72 }, { -11, 75 }, { -3, 71 },
    { 15, 46 }, { -13, 69 }, { 0, 62 }, { 0, 65 },
    { 21, 37 }, { -15, 72 }, { 9, 57 }, { 16, 54 },
    { 0, 62 }, { 12, 72 },

    /* 166 -> 196 */
    { 24, 0 }, { 15, 9 }, { 8, 25 }, { 13, 18 },
    { 15, 9 }, { 13, 19 }, { 10, 37 }, { 12, 18 },
    { 6, 29 }, { 20, 33 }, { 15, 30 }, { 4, 45 },
    { 1, 58 }, { 0, 62 }, { 7, 61 }, { 12, 38 },
    { 11, 45 }, { 15, 39 }, { 11, 42 }, { 13, 44 },
    { 16, 45 }, { 12, 41 }, { 10, 49 }, { 30, 34 },
    { 18, 42 }, { 10, 55 }, { 17, 51 }, { 17, 46 },
    { 0, 89 }, { 26, -19 }, { 22, -17 },

    /* 197 -> 226 */
    { 26, -17 }, { 30, -25 }, { 28, -20 }, { 33, -23 },
    { 37, -27 }, { 33, -23 }, { 40, -28 }, { 38, -17 },
    { 33, -11 }, { 40, -15 }, { 41, -6 }, { 38, 1 },
    { 41, 17 }, { 30, -6 }, { 27, 3 }, { 26, 22 },
    { 37, -16 }, { 35, -4 }, { 38, -8 }, { 38, -3 },
    { 37, 3 }, { 38, 5 }, { 42, 0 }, { 35, 16 },
    { 39, 22 }, { 14, 48 }, { 27, 37 }, { 21, 60 },
    { 12, 68 }, { 2, 97 },

    /* 227 -> 251 */
    { -3, 71 }, { -6, 42 }, { -5, 50 }, { -3, 54 },
    { -2, 62 }, { 0, 58 }, { 1, 63 }, { -2, 72 },
    { -1, 74 }, { -9, 91 }, { -5, 67 }, { -5, 27 },
    { -3, 39 }, { -2, 44 }, { 0, 46 }, { -16, 64 },
    { -8, 68 }, { -10, 78 }, { -6, 77 }, { -10, 86 },
    { -12, 92 }, { -15, 55 }, { -10, 60 }, { -6, 62 },
    { -4, 65 },

    /* 252 -> 275 */
    { -12, 73 }, { -8, 76 }, { -7, 80 }, { -9, 88 },
    { -17, 110 }, { -11, 97 }, { -20, 84 }, { -11, 79 },
    { -6, 73 }, { -4, 74 }, { -13, 86 }, { -13, 96 },
    { -11, 97 }, { -19, 117 }, { -8, 78 }, { -5, 33 },
    { -4, 48 }, { -2, 53 }, { -3, 62 }, { -13, 71 },
    { -10, 79 }, { -12, 86 }, { -13, 90 }, { -14, 97 },

    /* 276 special case, bypass used */
    { 0, 0 },

    /* 277 -> 307 */
    { -6, 93 }, { -6, 84 }, { -8, 79 }, { 0, 66 },
    { -1, 71 }, { 0, 62 }, { -2, 60 }, { -2, 59 },
    { -5, 75 }, { -3, 62 }, { -4, 58 }, { -9, 66 },
    { -1, 79 }, { 0, 71 }, { 3, 68 }, { 10, 44 },
    { -7, 62 }, { 15, 36 }, { 14, 40 }, { 16, 27 },
    { 12, 29 }, { 1, 44 }, { 20, 36 }, { 18, 32 },
    { 5, 42 }, { 1, 48 }, { 10, 62 }, { 17, 46 },
    { 9, 64 }, { -12, 104 }, { -11, 97 },

    /* 308 -> 337 */
    { -16, 96 }, { -7, 88 }, { -8, 85 }, { -7, 85 },
    { -9, 85 }, { -13, 88 }, { 4, 66 }, { -3, 77 },
    { -3, 76 }, { -6, 76 }, { 10, 58 }, { -1, 76 },
    { -1, 83 }, { -7, 99 }, { -14, 95 }, { 2, 95 },
    { 0, 76 }, { -5, 74 }, { 0, 70 }, { -11, 75 },
    { 1, 68 }, { 0, 65 }, { -14, 73 }, { 3, 62 },
    { 4, 62 }, { -1, 68 }, { -13, 75 }, { 11, 55 },
    { 5, 64 }, { 12, 70 },

    /* 338 -> 368 */
    { 15, 6 }, { 6, 19 }, { 7, 16 }, { 12, 14 },
    { 18, 13 }, { 13, 11 }, { 13, 15 }, { 15, 16 },
    { 12, 23 }, { 13, 23 }, { 15, 20 }, { 14, 26 },
    { 14, 44 }, { 17, 40 }, { 17, 47 }, { 24, 17 },
    { 21, 21 }, { 25, 22 }, { 31, 27 }, { 22, 29 },
    { 19, 35 }, { 14, 50 }, { 10, 57 }, { 7, 63 },
    { -2, 77 }, { -4, 82 }, { -3, 94 }, { 9, 69 },
    { -12, 109 }, { 36, -35 }, { 36, -34 },

    /* 369 -> 398 */
    { 32, -26 }, { 37, -30 }, { 44, -32 }, { 34, -18 },
    { 34, -15 }, { 40, -15 }, { 33, -7 }, { 35, -5 },
    { 33, 0 }, { 38, 2 }, { 33, 13 }, { 23, 35 },
    { 13, 58 }, { 29, -3 }, { 26, 0 }, { 22, 30 },
    { 31, -7 }, { 35, -15 }, { 34, -3 }, { 34, 3 },
    { 36, -1 }, { 34, 5 }, { 32, 11 }, { 35, 5 },
    { 34, 12 }, { 39, 11 }, { 30, 29 }, { 34, 26 },
    { 29, 39 }, { 19, 66 },

    /* 399 -> 435 */
    { 31, 21 }, { 31, 31 }, { 25, 50 },
    { -17, 120 }, { -20, 112 }, { -18, 114 }, { -11, 85 },
    { -15, 92 }, { -14, 89 }, { -26, 71 }, { -15, 81 },
    { -14, 80 }, { 0, 68 }, { -14, 70 }, { -24, 56 },
    { -23, 68 }, { -24, 50 }, { -11, 74 }, { 23, -13 },
    { 26, -13 }, { 40, -15 }, { 49, -14 }, { 44, 3 },
    { 45, 6 }, { 44, 34 }, { 33, 54 }, { 19, 82 },
    { -3, 75 }, { -1, 23 }, { 1, 34 }, { 1, 43 },
    { 0, 54 }, { -2, 55 }, { 0, 61 }, { 1, 64 },
    { 0, 68 }, { -9, 92 },

    /* 436 -> 459 */
    { -14, 106 }, { -13, 97 }, { -15, 90 }, { -12, 90 },
    { -18, 88 }, { -10, 73 }, { -9, 79 }, { -14, 86 },
    { -10, 73 }, { -10, 70 }, { -10, 69 }, { -5, 66 },
    { -9, 64 }, { -5, 58 }, { 2, 59 }, { 21, -10 },
    { 24, -11 }, { 28, -8 }, { 28, -1 }, { 29, 3 },
    { 29, 9 }, { 35, 20 }, { 29, 36 }, { 14, 67 }
};

const RK_S32 h264_context_init[3][460][2] = {
    /* cabac_init_idc == 0 */
    {
        /* 0 -> 10 */
        { 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
        { 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
        { -6, 53 }, { -1, 54 }, { 7, 51 },

        /* 11 -> 23 */
        { 23, 33 }, { 23, 2 }, { 21, 0 }, { 1, 9 },
        { 0, 49 }, { -37, 118 }, { 5, 57 }, { -13, 78 },
        { -11, 65 }, { 1, 62 }, { 12, 49 }, { -4, 73 },
        { 17, 50 },

        /* 24 -> 39 */
        { 18, 64 }, { 9, 43 }, { 29, 0 }, { 26, 67 },
        { 16, 90 }, { 9, 104 }, { -46, 127 }, { -20, 104 },
        { 1, 67 }, { -13, 78 }, { -11, 65 }, { 1, 62 },
        { -6, 86 }, { -17, 95 }, { -6, 61 }, { 9, 45 },

        /* 40 -> 53 */
        { -3, 69 }, { -6, 81 }, { -11, 96 }, { 6, 55 },
        { 7, 67 }, { -5, 86 }, { 2, 88 }, { 0, 58 },
        { -3, 76 }, { -10, 94 }, { 5, 54 }, { 4, 69 },
        { -3, 81 }, { 0, 88 },

        /* 54 -> 59 */
        { -7, 67 }, { -5, 74 }, { -4, 74 }, { -5, 80 },
        { -7, 72 }, { 1, 58 },

        /* 60 -> 69 */
        { 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
        { -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
        { 13, 41 }, { 3, 62 },

        /* 70 -> 87 */
        { 0, 45 }, { -4, 78 }, { -3, 96 }, { -27, 126 },
        { -28, 98 }, { -25, 101 }, { -23, 67 }, { -28, 82 },
        { -20, 94 }, { -16, 83 }, { -22, 110 }, { -21, 91 },
        { -18, 102 }, { -13, 93 }, { -29, 127 }, { -7, 92 },
        { -5, 89 }, { -7, 96 }, { -13, 108 }, { -3, 46 },
        { -1, 65 }, { -1, 57 }, { -9, 93 }, { -3, 74 },
        { -9, 92 }, { -8, 87 }, { -23, 126 }, { 5, 54 },
        { 6, 60 }, { 6, 59 }, { 6, 69 }, { -1, 48 },
        { 0, 68 }, { -4, 69 }, { -8, 88 },

        /* 105 -> 165 */
        { -2, 85 }, { -6, 78 }, { -1, 75 }, { -7, 77 },
        { 2, 54 }, { 5, 50 }, { -3, 68 }, { 1, 50 },
        { 6, 42 }, { -4, 81 }, { 1, 63 }, { -4, 70 },
        { 0, 67 }, { 2, 57 }, { -2, 76 }, { 11, 35 },
        { 4, 64 }, { 1, 61 }, { 11, 35 }, { 18, 25 },
        { 12, 24 }, { 13, 29 }, { 13, 36 }, { -10, 93 },
        { -7, 73 }, { -2, 73 }, { 13, 46 }, { 9, 49 },
        { -7, 100 }, { 9, 53 }, { 2, 53 }, { 5, 53 },
        { -2, 61 }, { 0, 56 }, { 0, 56 }, { -13, 63 },
        { -5, 60 }, { -1, 62 }, { 4, 57 }, { -6, 69 },
        { 4, 57 }, { 14, 39 }, { 4, 51 }, { 13, 68 },
        { 3, 64 }, { 1, 61 }, { 9, 63 }, { 7, 50 },
        { 16, 39 }, { 5, 44 }, { 4, 52 }, { 11, 48 },
        { -5, 60 }, { -1, 59 }, { 0, 59 }, { 22, 33 },
        { 5, 44 }, { 14, 43 }, { -1, 78 }, { 0, 60 },
        { 9, 69 },

        /* 166 -> 226 */
        { 11, 28 }, { 2, 40 }, { 3, 44 }, { 0, 49 },
        { 0, 46 }, { 2, 44 }, { 2, 51 }, { 0, 47 },
        { 4, 39 }, { 2, 62 }, { 6, 46 }, { 0, 54 },
        { 3, 54 }, { 2, 58 }, { 4, 63 }, { 6, 51 },
        { 6, 57 }, { 7, 53 }, { 6, 52 }, { 6, 55 },
        { 11, 45 }, { 14, 36 }, { 8, 53 }, { -1, 82 },
        { 7, 55 }, { -3, 78 }, { 15, 46 }, { 22, 31 },
        { -1, 84 }, { 25, 7 }, { 30, -7 }, { 28, 3 },
        { 28, 4 }, { 32, 0 }, { 34, -1 }, { 30, 6 },
        { 30, 6 }, { 32, 9 }, { 31, 19 }, { 26, 27 },
        { 26, 30 }, { 37, 20 }, { 28, 34 }, { 17, 70 },
        { 1, 67 }, { 5, 59 }, { 9, 67 }, { 16, 30 },
        { 18, 32 }, { 18, 35 }, { 22, 29 }, { 24, 31 },
        { 23, 38 }, { 18, 43 }, { 20, 41 }, { 11, 63 },
        { 9, 59 }, { 9, 64 }, { -1, 94 }, { -2, 89 },
        { -9, 108 },

        /* 227 -> 275 */
        { -6, 76 }, { -2, 44 }, { 0, 45 }, { 0, 52 },
        { -3, 64 }, { -2, 59 }, { -4, 70 }, { -4, 75 },
        { -8, 82 }, { -17, 102 }, { -9, 77 }, { 3, 24 },
        { 0, 42 }, { 0, 48 }, { 0, 55 }, { -6, 59 },
        { -7, 71 }, { -12, 83 }, { -11, 87 }, { -30, 119 },
        { 1, 58 }, { -3, 29 }, { -1, 36 }, { 1, 38 },
        { 2, 43 }, { -6, 55 }, { 0, 58 }, { 0, 64 },
        { -3, 74 }, { -10, 90 }, { 0, 70 }, { -4, 29 },
        { 5, 31 }, { 7, 42 }, { 1, 59 }, { -2, 58 },
        { -3, 72 }, { -3, 81 }, { -11, 97 }, { 0, 58 },
        { 8, 5 }, { 10, 14 }, { 14, 18 }, { 13, 27 },
        { 2, 40 }, { 0, 58 }, { -3, 70 }, { -6, 79 },
        { -8, 85 },

        /* 276 special case, bypass used */
        { 0, 0 },

        /* 277 -> 337 */
        { -13, 106 }, { -16, 106 }, { -10, 87 }, { -21, 114 },
        { -18, 110 }, { -14, 98 }, { -22, 110 }, { -21, 106 },
        { -18, 103 }, { -21, 107 }, { -23, 108 }, { -26, 112 },
        { -10, 96 }, { -12, 95 }, { -5, 91 }, { -9, 93 },
        { -22, 94 }, { -5, 86 }, { 9, 67 }, { -4, 80 },
        { -10, 85 }, { -1, 70 }, { 7, 60 }, { 9, 58 },
        { 5, 61 }, { 12, 50 }, { 15, 50 }, { 18, 49 },
        { 17, 54 }, { 10, 41 }, { 7, 46 }, { -1, 51 },
        { 7, 49 }, { 8, 52 }, { 9, 41 }, { 6, 47 },
        { 2, 55 }, { 13, 41 }, { 10, 44 }, { 6, 50 },
        { 5, 53 }, { 13, 49 }, { 4, 63 }, { 6, 64 },
        { -2, 69 }, { -2, 59 }, { 6, 70 }, { 10, 44 },
        { 9, 31 }, { 12, 43 }, { 3, 53 }, { 14, 34 },
        { 10, 38 }, { -3, 52 }, { 13, 40 }, { 17, 32 },
        { 7, 44 }, { 7, 38 }, { 13, 50 }, { 10, 57 },
        { 26, 43 },

        /* 338 -> 398 */
        { 14, 11 }, { 11, 14 }, { 9, 11 }, { 18, 11 },
        { 21, 9 }, { 23, -2 }, { 32, -15 }, { 32, -15 },
        { 34, -21 }, { 39, -23 }, { 42, -33 }, { 41, -31 },
        { 46, -28 }, { 38, -12 }, { 21, 29 }, { 45, -24 },
        { 53, -45 }, { 48, -26 }, { 65, -43 }, { 43, -19 },
        { 39, -10 }, { 30, 9 }, { 18, 26 }, { 20, 27 },
        { 0, 57 }, { -14, 82 }, { -5, 75 }, { -19, 97 },
        { -35, 125 }, { 27, 0 }, { 28, 0 }, { 31, -4 },
        { 27, 6 }, { 34, 8 }, { 30, 10 }, { 24, 22 },
        { 33, 19 }, { 22, 32 }, { 26, 31 }, { 21, 41 },
        { 26, 44 }, { 23, 47 }, { 16, 65 }, { 14, 71 },
        { 8, 60 }, { 6, 63 }, { 17, 65 }, { 21, 24 },
        { 23, 20 }, { 26, 23 }, { 27, 32 }, { 28, 23 },
        { 28, 24 }, { 23, 40 }, { 24, 32 }, { 28, 29 },
        { 23, 42 }, { 19, 57 }, { 22, 53 }, { 22, 61 },
        { 11, 86 },

        /* 399 -> 435 */
        { 12, 40 }, { 11, 51 }, { 14, 59 },
        { -4, 79 }, { -7, 71 }, { -5, 69 }, { -9, 70 },
        { -8, 66 }, { -10, 68 }, { -19, 73 }, { -12, 69 },
        { -16, 70 }, { -15, 67 }, { -20, 62 }, { -19, 70 },
        { -16, 66 }, { -22, 65 }, { -20, 63 }, { 9, -2 },
        { 26, -9 }, { 33, -9 }, { 39, -7 }, { 41, -2 },
        { 45, 3 }, { 49, 9 }, { 45, 27 }, { 36, 59 },
        { -6, 66 }, { -7, 35 }, { -7, 42 }, { -8, 45 },
        { -5, 48 }, { -12, 56 }, { -6, 60 }, { -5, 62 },
        { -8, 66 }, { -8, 76 },

        /* 436 -> 459 */
        { -5, 85 }, { -6, 81 }, { -10, 77 }, { -7, 81 },
        { -17, 80 }, { -18, 73 }, { -4, 74 }, { -10, 83 },
        { -9, 71 }, { -9, 67 }, { -1, 61 }, { -8, 66 },
        { -14, 66 }, { 0, 59 }, { 2, 59 }, { 21, -13 },
        { 33, -14 }, { 39, -7 }, { 46, -2 }, { 51, 2 },
        { 60, 6 }, { 61, 17 }, { 55, 34 }, { 42, 62 },
    },

    /* cabac_init_idc == 1 */
    {
        /* 0 -> 10 */
        { 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
        { 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
        { -6, 53 }, { -1, 54 }, { 7, 51 },

        /* 11 -> 23 */
        { 22, 25 }, { 34, 0 }, { 16, 0 }, { -2, 9 },
        { 4, 41 }, { -29, 118 }, { 2, 65 }, { -6, 71 },
        { -13, 79 }, { 5, 52 }, { 9, 50 }, { -3, 70 },
        { 10, 54 },

        /* 24 -> 39 */
        { 26, 34 }, { 19, 22 }, { 40, 0 }, { 57, 2 },
        { 41, 36 }, { 26, 69 }, { -45, 127 }, { -15, 101 },
        { -4, 76 }, { -6, 71 }, { -13, 79 }, { 5, 52 },
        { 6, 69 }, { -13, 90 }, { 0, 52 }, { 8, 43 },

        /* 40 -> 53 */
        { -2, 69 }, { -5, 82 }, { -10, 96 }, { 2, 59 },
        { 2, 75 }, { -3, 87 }, { -3, 100 }, { 1, 56 },
        { -3, 74 }, { -6, 85 }, { 0, 59 }, { -3, 81 },
        { -7, 86 }, { -5, 95 },

        /* 54 -> 59 */
        { -1, 66 }, { -1, 77 }, { 1, 70 }, { -2, 86 },
        { -5, 72 }, { 0, 61 },

        /* 60 -> 69 */
        { 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
        { -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
        { 13, 41 }, { 3, 62 },

        /* 70 -> 104 */
        { 13, 15 }, { 7, 51 }, { 2, 80 }, { -39, 127 },
        { -18, 91 }, { -17, 96 }, { -26, 81 }, { -35, 98 },
        { -24, 102 }, { -23, 97 }, { -27, 119 }, { -24, 99 },
        { -21, 110 }, { -18, 102 }, { -36, 127 }, { 0, 80 },
        { -5, 89 }, { -7, 94 }, { -4, 92 }, { 0, 39 },
        { 0, 65 }, { -15, 84 }, { -35, 127 }, { -2, 73 },
        { -12, 104 }, { -9, 91 }, { -31, 127 }, { 3, 55 },
        { 7, 56 }, { 7, 55 }, { 8, 61 }, { -3, 53 },
        { 0, 68 }, { -7, 74 }, { -9, 88 },

        /* 105 -> 165 */
        { -13, 103 }, { -13, 91 }, { -9, 89 }, { -14, 92 },
        { -8, 76 }, { -12, 87 }, { -23, 110 }, { -24, 105 },
        { -10, 78 }, { -20, 112 }, { -17, 99 }, { -78, 127 },
        { -70, 127 }, { -50, 127 }, { -46, 127 }, { -4, 66 },
        { -5, 78 }, { -4, 71 }, { -8, 72 }, { 2, 59 },
        { -1, 55 }, { -7, 70 }, { -6, 75 }, { -8, 89 },
        { -34, 119 }, { -3, 75 }, { 32, 20 }, { 30, 22 },
        { -44, 127 }, { 0, 54 }, { -5, 61 }, { 0, 58 },
        { -1, 60 }, { -3, 61 }, { -8, 67 }, { -25, 84 },
        { -14, 74 }, { -5, 65 }, { 5, 52 }, { 2, 57 },
        { 0, 61 }, { -9, 69 }, { -11, 70 }, { 18, 55 },
        { -4, 71 }, { 0, 58 }, { 7, 61 }, { 9, 41 },
        { 18, 25 }, { 9, 32 }, { 5, 43 }, { 9, 47 },
        { 0, 44 }, { 0, 51 }, { 2, 46 }, { 19, 38 },
        { -4, 66 }, { 15, 38 }, { 12, 42 }, { 9, 34 },
        { 0, 89 },

        /* 166 -> 226 */
        { 4, 45 }, { 10, 28 }, { 10, 31 }, { 33, -11 },
        { 52, -43 }, { 18, 15 }, { 28, 0 }, { 35, -22 },
        { 38, -25 }, { 34, 0 }, { 39, -18 }, { 32, -12 },
        { 102, -94 }, { 0, 0 }, { 56, -15 }, { 33, -4 },
        { 29, 10 }, { 37, -5 }, { 51, -29 }, { 39, -9 },
        { 52, -34 }, { 69, -58 }, { 67, -63 }, { 44, -5 },
        { 32, 7 }, { 55, -29 }, { 32, 1 }, { 0, 0 },
        { 27, 36 }, { 33, -25 }, { 34, -30 }, { 36, -28 },
        { 38, -28 }, { 38, -27 }, { 34, -18 }, { 35, -16 },
        { 34, -14 }, { 32, -8 }, { 37, -6 }, { 35, 0 },
        { 30, 10 }, { 28, 18 }, { 26, 25 }, { 29, 41 },
        { 0, 75 }, { 2, 72 }, { 8, 77 }, { 14, 35 },
        { 18, 31 }, { 17, 35 }, { 21, 30 }, { 17, 45 },
        { 20, 42 }, { 18, 45 }, { 27, 26 }, { 16, 54 },
        { 7, 66 }, { 16, 56 }, { 11, 73 }, { 10, 67 },
        { -10, 116 },

        /* 227 -> 275 */
        { -23, 112 }, { -15, 71 }, { -7, 61 }, { 0, 53 },
        { -5, 66 }, { -11, 77 }, { -9, 80 }, { -9, 84 },
        { -10, 87 }, { -34, 127 }, { -21, 101 }, { -3, 39 },
        { -5, 53 }, { -7, 61 }, { -11, 75 }, { -15, 77 },
        { -17, 91 }, { -25, 107 }, { -25, 111 }, { -28, 122 },
        { -11, 76 }, { -10, 44 }, { -10, 52 }, { -10, 57 },
        { -9, 58 }, { -16, 72 }, { -7, 69 }, { -4, 69 },
        { -5, 74 }, { -9, 86 }, { 2, 66 }, { -9, 34 },
        { 1, 32 }, { 11, 31 }, { 5, 52 }, { -2, 55 },
        { -2, 67 }, { 0, 73 }, { -8, 89 }, { 3, 52 },
        { 7, 4 }, { 10, 8 }, { 17, 8 }, { 16, 19 },
        { 3, 37 }, { -1, 61 }, { -5, 73 }, { -1, 70 },
        { -4, 78 },

        /* 276 special case, bypass used */
        { 0, 0 },

        /* 277 -> 337 */
        { -21, 126 }, { -23, 124 }, { -20, 110 }, { -26, 126 },
        { -25, 124 }, { -17, 105 }, { -27, 121 }, { -27, 117 },
        { -17, 102 }, { -26, 117 }, { -27, 116 }, { -33, 122 },
        { -10, 95 }, { -14, 100 }, { -8, 95 }, { -17, 111 },
        { -28, 114 }, { -6, 89 }, { -2, 80 }, { -4, 82 },
        { -9, 85 }, { -8, 81 }, { -1, 72 }, { 5, 64 },
        { 1, 67 }, { 9, 56 }, { 0, 69 }, { 1, 69 },
        { 7, 69 }, { -7, 69 }, { -6, 67 }, { -16, 77 },
        { -2, 64 }, { 2, 61 }, { -6, 67 }, { -3, 64 },
        { 2, 57 }, { -3, 65 }, { -3, 66 }, { 0, 62 },
        { 9, 51 }, { -1, 66 }, { -2, 71 }, { -2, 75 },
        { -1, 70 }, { -9, 72 }, { 14, 60 }, { 16, 37 },
        { 0, 47 }, { 18, 35 }, { 11, 37 }, { 12, 41 },
        { 10, 41 }, { 2, 48 }, { 12, 41 }, { 13, 41 },
        { 0, 59 }, { 3, 50 }, { 19, 40 }, { 3, 66 },
        { 18, 50 },

        /* 338 -> 398 */
        { 19, -6 }, { 18, -6 }, { 14, 0 }, { 26, -12 },
        { 31, -16 }, { 33, -25 }, { 33, -22 }, { 37, -28 },
        { 39, -30 }, { 42, -30 }, { 47, -42 }, { 45, -36 },
        { 49, -34 }, { 41, -17 }, { 32, 9 }, { 69, -71 },
        { 63, -63 }, { 66, -64 }, { 77, -74 }, { 54, -39 },
        { 52, -35 }, { 41, -10 }, { 36, 0 }, { 40, -1 },
        { 30, 14 }, { 28, 26 }, { 23, 37 }, { 12, 55 },
        { 11, 65 }, { 37, -33 }, { 39, -36 }, { 40, -37 },
        { 38, -30 }, { 46, -33 }, { 42, -30 }, { 40, -24 },
        { 49, -29 }, { 38, -12 }, { 40, -10 }, { 38, -3 },
        { 46, -5 }, { 31, 20 }, { 29, 30 }, { 25, 44 },
        { 12, 48 }, { 11, 49 }, { 26, 45 }, { 22, 22 },
        { 23, 22 }, { 27, 21 }, { 33, 20 }, { 26, 28 },
        { 30, 24 }, { 27, 34 }, { 18, 42 }, { 25, 39 },
        { 18, 50 }, { 12, 70 }, { 21, 54 }, { 14, 71 },
        { 11, 83 },

        /* 399 -> 435 */
        { 25, 32 }, { 21, 49 }, { 21, 54 },
        { -5, 85 }, { -6, 81 }, { -10, 77 }, { -7, 81 },
        { -17, 80 }, { -18, 73 }, { -4, 74 }, { -10, 83 },
        { -9, 71 }, { -9, 67 }, { -1, 61 }, { -8, 66 },
        { -14, 66 }, { 0, 59 }, { 2, 59 }, { 17, -10 },
        { 32, -13 }, { 42, -9 }, { 49, -5 }, { 53, 0 },
        { 64, 3 }, { 68, 10 }, { 66, 27 }, { 47, 57 },
        { -5, 71 }, { 0, 24 }, { -1, 36 }, { -2, 42 },
        { -2, 52 }, { -9, 57 }, { -6, 63 }, { -4, 65 },
        { -4, 67 }, { -7, 82 },

        /* 436 -> 459 */
        { -3, 81 }, { -3, 76 }, { -7, 72 }, { -6, 78 },
        { -12, 72 }, { -14, 68 }, { -3, 70 }, { -6, 76 },
        { -5, 66 }, { -5, 62 }, { 0, 57 }, { -4, 61 },
        { -9, 60 }, { 1, 54 }, { 2, 58 }, { 17, -10 },
        { 32, -13 }, { 42, -9 }, { 49, -5 }, { 53, 0 },
        { 64, 3 }, { 68, 10 }, { 66, 27 }, { 47, 57 },
    },

    /* cabac_init_idc == 2 */
    {
        /* 0 -> 10 */
        { 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
        { 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
        { -6, 53 }, { -1, 54 }, { 7, 51 },

        /* 11 -> 23 */
        { 29, 16 }, { 25, 0 }, { 14, 0 }, { -10, 51 },
        { -3, 62 }, { -27, 99 }, { 26, 16 }, { -4, 85 },
        { -24, 102 }, { 5, 57 }, { 6, 57 }, { -17, 73 },
        { 14, 57 },

        /* 24 -> 39 */
        { 20, 40 }, { 20, 10 }, { 29, 0 }, { 54, 0 },
        { 37, 42 }, { 12, 97 }, { -32, 127 }, { -22, 117 },
        { -2, 74 }, { -4, 85 }, { -24, 102 }, { 5, 57 },
        { -6, 93 }, { -14, 88 }, { -6, 44 }, { 4, 55 },

        /* 40 -> 53 */
        { -11, 89 }, { -15, 103 }, { -21, 116 }, { 19, 57 },
        { 20, 58 }, { 4, 84 }, { 6, 96 }, { 1, 63 },
        { -5, 85 }, { -13, 106 }, { 5, 63 }, { 6, 75 },
        { -3, 90 }, { -1, 101 },

        /* 54 -> 59 */
        { 3, 55 }, { -4, 79 }, { -2, 75 }, { -12, 97 },
        { -7, 50 }, { 1, 60 },

        /* 60 -> 69 */
        { 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
        { -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
        { 13, 41 }, { 3, 62 },

        /* 70 -> 104 */
        { 7, 34 }, { -9, 88 }, { -20, 127 }, { -36, 127 },
        { -17, 91 }, { -14, 95 }, { -25, 84 }, { -25, 86 },
        { -12, 89 }, { -17, 91 }, { -31, 127 }, { -14, 76 },
        { -18, 103 }, { -13, 90 }, { -37, 127 }, { 11, 80 },
        { 5, 76 }, { 2, 84 }, { 5, 78 }, { -6, 55 },
        { 4, 61 }, { -14, 83 }, { -37, 127 }, { -5, 79 },
        { -11, 104 }, { -11, 91 }, { -30, 127 }, { 0, 65 },
        { -2, 79 }, { 0, 72 }, { -4, 92 }, { -6, 56 },
        { 3, 68 }, { -8, 71 }, { -13, 98 },

        /* 105 -> 165 */
        { -4, 86 }, { -12, 88 }, { -5, 82 }, { -3, 72 },
        { -4, 67 }, { -8, 72 }, { -16, 89 }, { -9, 69 },
        { -1, 59 }, { 5, 66 }, { 4, 57 }, { -4, 71 },
        { -2, 71 }, { 2, 58 }, { -1, 74 }, { -4, 44 },
        { -1, 69 }, { 0, 62 }, { -7, 51 }, { -4, 47 },
        { -6, 42 }, { -3, 41 }, { -6, 53 }, { 8, 76 },
        { -9, 78 }, { -11, 83 }, { 9, 52 }, { 0, 67 },
        { -5, 90 }, { 1, 67 }, { -15, 72 }, { -5, 75 },
        { -8, 80 }, { -21, 83 }, { -21, 64 }, { -13, 31 },
        { -25, 64 }, { -29, 94 }, { 9, 75 }, { 17, 63 },
        { -8, 74 }, { -5, 35 }, { -2, 27 }, { 13, 91 },
        { 3, 65 }, { -7, 69 }, { 8, 77 }, { -10, 66 },
        { 3, 62 }, { -3, 68 }, { -20, 81 }, { 0, 30 },
        { 1, 7 }, { -3, 23 }, { -21, 74 }, { 16, 66 },
        { -23, 124 }, { 17, 37 }, { 44, -18 }, { 50, -34 },
        { -22, 127 },

        /* 166 -> 226 */
        { 4, 39 }, { 0, 42 }, { 7, 34 }, { 11, 29 },
        { 8, 31 }, { 6, 37 }, { 7, 42 }, { 3, 40 },
        { 8, 33 }, { 13, 43 }, { 13, 36 }, { 4, 47 },
        { 3, 55 }, { 2, 58 }, { 6, 60 }, { 8, 44 },
        { 11, 44 }, { 14, 42 }, { 7, 48 }, { 4, 56 },
        { 4, 52 }, { 13, 37 }, { 9, 49 }, { 19, 58 },
        { 10, 48 }, { 12, 45 }, { 0, 69 }, { 20, 33 },
        { 8, 63 }, { 35, -18 }, { 33, -25 }, { 28, -3 },
        { 24, 10 }, { 27, 0 }, { 34, -14 }, { 52, -44 },
        { 39, -24 }, { 19, 17 }, { 31, 25 }, { 36, 29 },
        { 24, 33 }, { 34, 15 }, { 30, 20 }, { 22, 73 },
        { 20, 34 }, { 19, 31 }, { 27, 44 }, { 19, 16 },
        { 15, 36 }, { 15, 36 }, { 21, 28 }, { 25, 21 },
        { 30, 20 }, { 31, 12 }, { 27, 16 }, { 24, 42 },
        { 0, 93 }, { 14, 56 }, { 15, 57 }, { 26, 38 },
        { -24, 127 },

        /* 227 -> 275 */
        { -24, 115 }, { -22, 82 }, { -9, 62 }, { 0, 53 },
        { 0, 59 }, { -14, 85 }, { -13, 89 }, { -13, 94 },
        { -11, 92 }, { -29, 127 }, { -21, 100 }, { -14, 57 },
        { -12, 67 }, { -11, 71 }, { -10, 77 }, { -21, 85 },
        { -16, 88 }, { -23, 104 }, { -15, 98 }, { -37, 127 },
        { -10, 82 }, { -8, 48 }, { -8, 61 }, { -8, 66 },
        { -7, 70 }, { -14, 75 }, { -10, 79 }, { -9, 83 },
        { -12, 92 }, { -18, 108 }, { -4, 79 }, { -22, 69 },
        { -16, 75 }, { -2, 58 }, { 1, 58 }, { -13, 78 },
        { -9, 83 }, { -4, 81 }, { -13, 99 }, { -13, 81 },
        { -6, 38 }, { -13, 62 }, { -6, 58 }, { -2, 59 },
        { -16, 73 }, { -10, 76 }, { -13, 86 }, { -9, 83 },
        { -10, 87 },

        /* 276 special case, bypass used */
        { 0, 0 },

        /* 277 -> 337 */
        { -22, 127 }, { -25, 127 }, { -25, 120 }, { -27, 127 },
        { -19, 114 }, { -23, 117 }, { -25, 118 }, { -26, 117 },
        { -24, 113 }, { -28, 118 }, { -31, 120 }, { -37, 124 },
        { -10, 94 }, { -15, 102 }, { -10, 99 }, { -13, 106 },
        { -50, 127 }, { -5, 92 }, { 17, 57 }, { -5, 86 },
        { -13, 94 }, { -12, 91 }, { -2, 77 }, { 0, 71 },
        { -1, 73 }, { 4, 64 }, { -7, 81 }, { 5, 64 },
        { 15, 57 }, { 1, 67 }, { 0, 68 }, { -10, 67 },
        { 1, 68 }, { 0, 77 }, { 2, 64 }, { 0, 68 },
        { -5, 78 }, { 7, 55 }, { 5, 59 }, { 2, 65 },
        { 14, 54 }, { 15, 44 }, { 5, 60 }, { 2, 70 },
        { -2, 76 }, { -18, 86 }, { 12, 70 }, { 5, 64 },
        { -12, 70 }, { 11, 55 }, { 5, 56 }, { 0, 69 },
        { 2, 65 }, { -6, 74 }, { 5, 54 }, { 7, 54 },
        { -6, 76 }, { -11, 82 }, { -2, 77 }, { -2, 77 },
        { 25, 42 },

        /* 338 -> 398 */
        { 17, -13 }, { 16, -9 }, { 17, -12 }, { 27, -21 },
        { 37, -30 }, { 41, -40 }, { 42, -41 }, { 48, -47 },
        { 39, -32 }, { 46, -40 }, { 52, -51 }, { 46, -41 },
        { 52, -39 }, { 43, -19 }, { 32, 11 }, { 61, -55 },
        { 56, -46 }, { 62, -50 }, { 81, -67 }, { 45, -20 },
        { 35, -2 }, { 28, 15 }, { 34, 1 }, { 39, 1 },
        { 30, 17 }, { 20, 38 }, { 18, 45 }, { 15, 54 },
        { 0, 79 }, { 36, -16 }, { 37, -14 }, { 37, -17 },
        { 32, 1 }, { 34, 15 }, { 29, 15 }, { 24, 25 },
        { 34, 22 }, { 31, 16 }, { 35, 18 }, { 31, 28 },
        { 33, 41 }, { 36, 28 }, { 27, 47 }, { 21, 62 },
        { 18, 31 }, { 19, 26 }, { 36, 24 }, { 24, 23 },
        { 27, 16 }, { 24, 30 }, { 31, 29 }, { 22, 41 },
        { 22, 42 }, { 16, 60 }, { 15, 52 }, { 14, 60 },
        { 3, 78 }, { -16, 123 }, { 21, 53 }, { 22, 56 },
        { 25, 61 },

        /* 399 -> 435 */
        { 21, 33 }, { 19, 50 }, { 17, 61 },
        { -3, 78 }, { -8, 74 }, { -9, 72 }, { -10, 72 },
        { -18, 75 }, { -12, 71 }, { -11, 63 }, { -5, 70 },
        { -17, 75 }, { -14, 72 }, { -16, 67 }, { -8, 53 },
        { -14, 59 }, { -9, 52 }, { -11, 68 }, { 9, -2 },
        { 30, -10 }, { 31, -4 }, { 33, -1 }, { 33, 7 },
        { 31, 12 }, { 37, 23 }, { 31, 38 }, { 20, 64 },
        { -9, 71 }, { -7, 37 }, { -8, 44 }, { -11, 49 },
        { -10, 56 }, { -12, 59 }, { -8, 63 }, { -9, 67 },
        { -6, 68 }, { -10, 79 },

        /* 436 -> 459 */
        { -3, 78 }, { -8, 74 }, { -9, 72 }, { -10, 72 },
        { -18, 75 }, { -12, 71 }, { -11, 63 }, { -5, 70 },
        { -17, 75 }, { -14, 72 }, { -16, 67 }, { -8, 53 },
        { -14, 59 }, { -9, 52 }, { -11, 68 }, { 9, -2 },
        { 30, -10 }, { 31, -4 }, { 33, -1 }, { 33, 7 },
        { 31, 12 }, { 37, 23 }, { 31, 38 }, { 20, 64 },
    }
};

#ifdef H264E_DUMP_DATA_TO_FILE
static MPP_RET hal_h264e_vpu_open_dump_files(void *dump_files)
{
    if (h264e_hal_log_mode & H264E_HAL_LOG_FILE) {
        char base_path[512];
        char full_path[512];
        h264e_hal_vpu_dump_files *files = (h264e_hal_vpu_dump_files *)dump_files;
        strcpy(base_path, "/sdcard/h264e_data/");

        sprintf(full_path, "%s%s", base_path, "mpp_syntax_in.txt");
        files->fp_mpp_syntax_in = fopen(full_path, "wb");
        if (!files->fp_mpp_syntax_in) {
            mpp_err("%s open error", full_path);
            return MPP_ERR_OPEN_FILE;
        }


        sprintf(full_path, "%s%s", base_path, "mpp_reg_in.txt");
        files->fp_mpp_reg_in = fopen(full_path, "wb");
        if (!files->fp_mpp_reg_in) {
            mpp_err("%s open error", full_path);
            return MPP_ERR_OPEN_FILE;
        }

        sprintf(full_path, "%s%s", base_path, "mpp_reg_out.txt");
        files->fp_mpp_reg_out = fopen(full_path, "wb");
        if (!files->fp_mpp_reg_out) {
            mpp_err("%s open error", full_path);
            return MPP_ERR_OPEN_FILE;
        }

        sprintf(full_path, "%s%s", base_path, "mpp_feedback.txt");
        files->fp_mpp_feedback = fopen(full_path, "wb");
        if (!files->fp_mpp_feedback) {
            mpp_err("%s open error", full_path);
            return MPP_ERR_OPEN_FILE;
        }

        sprintf(full_path, "%s%s", base_path, "mpp_strm_out.bin");
        files->fp_mpp_strm_out = fopen(full_path, "wb");
        if (!files->fp_mpp_strm_out) {
            mpp_err("%s open error", full_path);
            return MPP_ERR_OPEN_FILE;
        }
    }
    return MPP_OK;
}


static MPP_RET hal_h264e_vpu_close_dump_files(void *dump_files)
{
    h264e_hal_vpu_dump_files *files = (h264e_hal_vpu_dump_files *)dump_files;
    H264E_HAL_FCLOSE(files->fp_mpp_syntax_in);
    H264E_HAL_FCLOSE(files->fp_mpp_reg_in);
    H264E_HAL_FCLOSE(files->fp_mpp_reg_out);
    H264E_HAL_FCLOSE(files->fp_mpp_strm_out);
    H264E_HAL_FCLOSE(files->fp_mpp_feedback);
    return MPP_OK;
}

static void hal_h264e_vpu_dump_mpp_syntax_in(h264e_syntax *syn, h264e_hal_context *ctx)
{
    h264e_hal_vpu_dump_files *dump_files = (h264e_hal_vpu_dump_files *)ctx->dump_files;
    FILE *fp = dump_files->fp_mpp_syntax_in;
    if (fp) {
        RK_S32 k = 0;
        fprintf(fp, "#FRAME %d:\n", ctx->frame_cnt);
        fprintf(fp, "%-16d %s\n", syn->frame_coding_type, "frame_coding_type");
        fprintf(fp, "%-16d %s\n", syn->pic_init_qp, "pic_init_qp");
        fprintf(fp, "%-16d %s\n", syn->slice_alpha_offset, "slice_alpha_offset");
        fprintf(fp, "%-16d %s\n", syn->slice_beta_offset, "slice_beta_offset");
        fprintf(fp, "%-16d %s\n", syn->chroma_qp_index_offset, "chroma_qp_index_offset");
        fprintf(fp, "%-16d %s\n", syn->filter_disable, "filter_disable");
        fprintf(fp, "%-16d %s\n", syn->idr_pic_id, "idr_pic_id");
        fprintf(fp, "%-16d %s\n", syn->pps_id, "pps_id");
        fprintf(fp, "%-16d %s\n", syn->frame_num, "frame_num");
        fprintf(fp, "%-16d %s\n", syn->slice_size_mb_rows, "slice_size_mb_rows");
        fprintf(fp, "%-16d %s\n", syn->h264_inter4x4_disabled, "h264_inter4x4_disabled");
        fprintf(fp, "%-16d %s\n", syn->enable_cabac, "enable_cabac");
        fprintf(fp, "%-16d %s\n", syn->transform8x8_mode, "transform8x8_mode");
        fprintf(fp, "%-16d %s\n", syn->cabac_init_idc, "cabac_init_idc");
        fprintf(fp, "%-16d %s\n", syn->qp, "qp");
        fprintf(fp, "%-16d %s\n", syn->mad_qp_delta, "mad_qp_delta");
        fprintf(fp, "%-16d %s\n", syn->mad_threshold, "mad_threshold");
        fprintf(fp, "%-16d %s\n", syn->qp_min, "qp_min");
        fprintf(fp, "%-16d %s\n", syn->qp_max, "qp_max");
        fprintf(fp, "%-16d %s\n", syn->cp_distance_mbs, "cp_distance_mbs");
        for (k = 0; k < 10; k++)
            fprintf(fp, "%-16d cp_target[%d]\n", syn->cp_target[k], k);
        for (k = 0; k < 7; k++)
            fprintf(fp, "%-16d target_error[%d]\n", syn->target_error[k], k);
        for (k = 0; k < 7; k++)
            fprintf(fp, "%-16d delta_qp[%d]\n", syn->delta_qp[k], k);
        fprintf(fp, "%-16d %s\n", syn->output_strm_limit_size, "output_strm_limit_size");
        fprintf(fp, "%-16d %s\n", syn->pic_luma_width, "pic_luma_width");
        fprintf(fp, "%-16d %s\n", syn->pic_luma_height, "pic_luma_height");
        fprintf(fp, "%-16d %s\n", syn->input_image_format, "input_image_format");

        fprintf(fp, "%-16d %s\n", syn->color_conversion_coeff_a, "color_conversion_coeff_a");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_coeff_b, "color_conversion_coeff_b");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_coeff_c, "color_conversion_coeff_c");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_coeff_e, "color_conversion_coeff_e");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_coeff_f, "color_conversion_coeff_f");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_r_mask_msb, "color_conversion_r_mask_msb");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_g_mask_msb, "color_conversion_g_mask_msb");
        fprintf(fp, "%-16d %s\n", syn->color_conversion_b_mask_msb, "color_conversion_b_mask_msb");

        fprintf(fp, "\n");
        fflush(fp);
    } else {
        mpp_log("try to dump data to mpp_syntax_in.txt, but file is not opened");
    }
}

static void hal_h264e_vpu_dump_mpp_reg_in(h264e_hal_context *ctx)
{
    h264e_hal_vpu_dump_files *dump_files = (h264e_hal_vpu_dump_files *)ctx->dump_files;
    FILE *fp = dump_files->fp_mpp_reg_in;
    if (fp) {
        RK_S32 k = 0;
        RK_U32 *reg = (RK_U32 *)ctx->regs;
        fprintf(fp, "#FRAME %d:\n", ctx->frame_cnt);
        for (k = 0; k < VEPU_H264E_NUM_REGS; k++) {
            fprintf(fp, "reg[%03d/%03x]: %08x\n", k, k * 4, reg[k]);
            //mpp_log("reg[%03d/%03x]: %08x", k, k*4, reg[k]);
        }
        fprintf(fp, "\n");
    } else {
        mpp_log("try to dump data to mpp_reg_in.txt, but file is not opened");
    }
}

static void hal_h264e_vpu_dump_mpp_reg_out(h264e_hal_context *ctx)
{
    h264e_hal_vpu_dump_files *dump_files = (h264e_hal_vpu_dump_files *)ctx->dump_files;
    FILE *fp = dump_files->fp_mpp_reg_out;
    if (fp) {
        RK_S32 k = 0;
        RK_U32 *reg = (RK_U32 *)ctx->regs;
        fprintf(fp, "#FRAME %d:\n", ctx->frame_cnt - 1);
        for (k = 0; k < VEPU_H264E_NUM_REGS; k++) {
            fprintf(fp, "reg[%03d/%03x]: %08x\n", k, k * 4, reg[k]);
            //mpp_log("reg[%03d/%03x]: %08x", k, k*4, reg[k]);
        }
        fprintf(fp, "\n");
    } else {
        mpp_log("try to dump data to mpp_reg_in.txt, but file is not opened");
    }
}

static void hal_h264e_vpu_dump_mpp_feedback(h264e_hal_context *ctx)
{
    h264e_hal_vpu_dump_files *dump_files = (h264e_hal_vpu_dump_files *)ctx->dump_files;
    FILE *fp = dump_files->fp_mpp_feedback;
    if (fp) {
        RK_S32 k = 0;
        h264e_feedback *fb = &ctx->feedback;
        fprintf(fp, "#FRAME %d:\n", ctx->frame_cnt - 1);
        fprintf(fp, "%-16d %s\n", fb->hw_status, "hw_status");
        fprintf(fp, "%-16d %s\n", fb->out_strm_size, "out_strm_size");
        fprintf(fp, "%-16d %s\n", fb->qp_sum, "qp_sum");
        for (k = 0; k < 10; k++)
            fprintf(fp, "%-16d cp[%d]\n", fb->cp[k], k);
        fprintf(fp, "%-16d %s\n", fb->mad_count, "mad_count");
        fprintf(fp, "%-16d %s\n", fb->rlc_count, "rlc_count");

        fprintf(fp, "\n");
        fflush(fp);
    } else {
        mpp_log("try to dump data to mpp_feedback.txt, but file is not opened");
    }
}

static void hal_h264e_vpu_dump_mpp_strm_out_header(h264e_hal_context *ctx, MppPacket packet)
{
    h264e_hal_vpu_dump_files *dump_files = (h264e_hal_vpu_dump_files *)ctx->dump_files;
    void *ptr   = mpp_packet_get_data(packet);
    size_t len  = mpp_packet_get_length(packet);
    FILE *fp = dump_files->fp_mpp_strm_out;

    if (fp) {
        fwrite(ptr, 1, len, fp);
        fflush(fp);
    } else {
        mpp_log("try to dump strm header to mpp_strm_out.txt, but file is not opened");
    }
}

void hal_h264e_vpu_dump_mpp_strm_out(h264e_hal_context *ctx, MppBuffer hw_buf)
{
    h264e_hal_vpu_dump_files *dump_files = (h264e_hal_vpu_dump_files *)ctx->dump_files;
    FILE *fp = dump_files->fp_mpp_strm_out;
    if (fp && hw_buf) {
        RK_U32 *reg_val = (RK_U32 *)ctx->regs;
        RK_U32 strm_size = reg_val[VEPU_REG_STR_BUF_LIMIT / 4] / 8;

        RK_U8 *hw_buf_vir_addr = (RK_U8 *)mpp_buffer_get_ptr(hw_buf);

        mpp_log("strm_size: %d", strm_size);

        fwrite(hw_buf_vir_addr, 1, strm_size, fp);
        fflush(fp);
    } else {
        mpp_log("try to dump data to mpp_strm_out.txt, but file is not opened");
    }
}
#endif

static h264e_hal_vpu_csp_info hal_h264e_vpu_convert_csp(RK_S32 src_type)
{
    MppFrameFormat src_fmt = (MppFrameFormat)src_type;
    h264e_hal_vpu_csp_info dst_info;
    dst_info.fmt = 0;
    dst_info.r_mask_msb = 0;
    dst_info.g_mask_msb = 0;
    dst_info.b_mask_msb = 0;

    switch (src_fmt) {
    case MPP_FMT_YUV420P: {
        dst_info.fmt = H264E_VPU_CSP_YUV420P;
        break;
    }
    case MPP_FMT_YUV420SP: {
        dst_info.fmt = H264E_VPU_CSP_YUV420SP;
        break;
    }
    case MPP_FMT_YUV420SP_10BIT: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_YUV420SP_VU: { //TODO: to be confirmed
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_YUV422P: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_YUV422SP: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_YUV422SP_10BIT: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_YUV422SP_VU: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_YUV422_YUYV: {
        dst_info.fmt = H264E_VPU_CSP_YUYV422;
        break;
    }
    case MPP_FMT_YUV422_UYVY: {
        dst_info.fmt = H264E_VPU_CSP_UYVY422;
        break;
    }
    case MPP_FMT_RGB565: {
        dst_info.fmt = H264E_VPU_CSP_RGB565;
        dst_info.r_mask_msb = 15;
        dst_info.g_mask_msb = 10;
        dst_info.b_mask_msb = 4;
        break;
    }
    case MPP_FMT_BGR565: {
        dst_info.fmt = H264E_VPU_CSP_RGB565;
        dst_info.r_mask_msb = 4;
        dst_info.g_mask_msb = 10;
        dst_info.b_mask_msb = 15;
        break;
    }
    case MPP_FMT_RGB555: {
        dst_info.fmt = H264E_VPU_CSP_RGB555;
        dst_info.r_mask_msb = 14;
        dst_info.g_mask_msb = 9;
        dst_info.b_mask_msb = 4;
        break;
    }
    case MPP_FMT_BGR555: {
        dst_info.fmt = H264E_VPU_CSP_RGB555;
        dst_info.r_mask_msb = 14;
        dst_info.g_mask_msb = 9;
        dst_info.b_mask_msb = 4;
        break;
    }
    case MPP_FMT_RGB444: {
        dst_info.fmt = H264E_VPU_CSP_RGB444;
        dst_info.r_mask_msb = 11;
        dst_info.g_mask_msb = 7;
        dst_info.b_mask_msb = 3;
        break;
    }
    case MPP_FMT_BGR444: {
        dst_info.fmt = H264E_VPU_CSP_RGB444;
        dst_info.r_mask_msb = 11;
        dst_info.g_mask_msb = 7;
        dst_info.b_mask_msb = 3;
        break;
    }
    case MPP_FMT_RGB888: {
        dst_info.fmt = H264E_VPU_CSP_RGB888;
        dst_info.r_mask_msb = 23;
        dst_info.g_mask_msb = 15;
        dst_info.b_mask_msb = 7;
        break;
    }
    case MPP_FMT_BGR888: {
        dst_info.fmt = H264E_VPU_CSP_RGB888;
        dst_info.r_mask_msb = 23;
        dst_info.g_mask_msb = 15;
        dst_info.b_mask_msb = 7;
        break;
    }
    case MPP_FMT_RGB101010: {
        dst_info.fmt = H264E_VPU_CSP_RGB101010;
        dst_info.r_mask_msb = 29;
        dst_info.g_mask_msb = 19;
        dst_info.b_mask_msb = 9;
        break;
    }
    case MPP_FMT_BGR101010: {
        dst_info.fmt = H264E_VPU_CSP_RGB101010;
        dst_info.r_mask_msb = 29;
        dst_info.g_mask_msb = 19;
        dst_info.b_mask_msb = 9;
        break;
    }
    case MPP_FMT_ARGB8888: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    case MPP_FMT_ABGR8888: {
        dst_info.fmt = H264E_VPU_CSP_NONE;
        break;
    }
    default: {
        h264e_hal_log_err("unvalid src color space: %d", src_type);
        dst_info.fmt = H264E_VPU_CSP_NONE;
    }
    }

    return dst_info;
}


static MPP_RET hal_h264e_vpu_free_buffers(h264e_hal_context *ctx)
{
    RK_S32 k = 0;
    h264e_hal_vpu_buffers *buffers = (h264e_hal_vpu_buffers *)ctx->buffers;
    h264e_hal_debug_enter();

    if (buffers->hw_cabac_table_buf) {
        if (MPP_OK != mpp_buffer_put(buffers->hw_cabac_table_buf)) {
            mpp_err("hw_cabac_table_buf put failed");
            return MPP_NOK;
        }
    }

    if (buffers->hw_nal_size_table_buf) {
        if (MPP_OK != mpp_buffer_put(buffers->hw_nal_size_table_buf)) {
            mpp_err("hw_nal_size_table_buf put failed");
            return MPP_NOK;
        }
    }


    for (k = 0; k < 2; k++) {
        if (buffers->hw_rec_buf[k]) {
            if (MPP_OK != mpp_buffer_put(buffers->hw_rec_buf[k])) {
                mpp_err("hw_rec_buf[%d] put failed", k);
                return MPP_NOK;
            }
        }
    }

    if (buffers->hw_buf_grp) {
        if (MPP_OK != mpp_buffer_group_put(buffers->hw_buf_grp)) {
            mpp_err("buf group[%d] put failed", k);
            return MPP_NOK;
        }
        buffers->hw_buf_grp = NULL;
    }

    h264e_hal_debug_leave();
    return MPP_OK;
}

static void hal_h264e_vpu_write_cabac_table(h264e_syntax *syn, MppBuffer hw_cabac_tab_buf)
{
    const RK_S32(*context)[460][2];
    RK_S32 i, j, qp;

    RK_U8 table[H264E_CABAC_TABLE_BUF_SIZE] = {0};
    RK_U32 cabac_init_idc = syn->cabac_init_idc;

    h264e_hal_debug_enter();

    for (qp = 0; qp < 52; qp++) { /* All QP values */
        for (j = 0; j < 2; j++) { /* Intra/Inter */
            if (j == 0)
                /*lint -e(545) */
                context = &h264_context_init_intra;
            else
                /*lint -e(545) */
                context = &h264_context_init[cabac_init_idc];

            for (i = 0; i < 460; i++) {
                RK_S32 m = (RK_S32)(*context)[i][0];
                RK_S32 n = (RK_S32)(*context)[i][1];

                RK_S32 pre_ctx_state =
                    H264E_HAL_CLIP3(1, 126,
                                    ((m * (RK_S32)qp) >> 4) + n);

                if (pre_ctx_state <= 63) {
                    table[qp * 464 * 2 + j * 464 + i] =
                        (RK_U8)((63
                                 - pre_ctx_state) << 1);
                } else {
                    table[qp * 464 * 2 + j * 464 + i] =
                        (RK_U8)(((pre_ctx_state - 64)
                                 << 1) | 1);
                }
            }
        }
    }

    mpp_buffer_write(hw_cabac_tab_buf, 0, table, H264E_CABAC_TABLE_BUF_SIZE);

    h264e_hal_debug_leave();
}

static MPP_RET hal_h264e_vpu_allocate_buffers(h264e_hal_context *ctx, h264e_syntax *syn)
{
    MPP_RET ret = MPP_OK;
    RK_S32 k = 0;
    h264e_hal_vpu_buffers *buffers = (h264e_hal_vpu_buffers *)ctx->buffers;
    RK_U32 frame_size = ((syn->pic_luma_width + 15) & (~15)) * ((syn->pic_luma_height + 15) & (~15)) * 3 / 2;

    h264e_hal_debug_enter();
    ret = mpp_buffer_group_get_internal(&buffers->hw_buf_grp, MPP_BUFFER_TYPE_ION);
    if (ret) {
        mpp_err("buf group get failed ret %d\n", ret);
        return ret;
    }

    ret = mpp_buffer_get(buffers->hw_buf_grp, &buffers->hw_cabac_table_buf, H264E_CABAC_TABLE_BUF_SIZE);
    if (ret) {
        mpp_err("hw_cabac_table_buf get failed\n");
        return ret;
    }

    ret = mpp_buffer_get(buffers->hw_buf_grp, &buffers->hw_nal_size_table_buf, (sizeof(RK_U32) * (syn->pic_luma_height + 1) + 7) & (~7));
    if (ret) {
        mpp_err("hw_nal_size_table_buf get failed\n");
        return ret;
    }

    for (k = 0; k < 2; k++) {
        ret = mpp_buffer_get(buffers->hw_buf_grp, &buffers->hw_rec_buf[k], frame_size + 4096);
        if (ret) {
            mpp_err("hw_rec_buf[%d] get failed\n", k);
            return ret;
        }
    }

    hal_h264e_vpu_write_cabac_table(syn, buffers->hw_cabac_table_buf);

    h264e_hal_debug_leave();
    return MPP_OK;
}


static MPP_RET hal_h264e_vpu_stream_buffer_status(h264e_hal_vpu_stream *stream)
{
    if (stream->byte_cnt + 5 > stream->size) {
        stream->overflow = 1;
        return MPP_NOK;
    }

    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_stream_buffer_reset(h264e_hal_vpu_stream *strmbuf)
{
    strmbuf->stream = strmbuf->buffer;
    strmbuf->byte_cnt = 0;
    strmbuf->overflow = 0;
    strmbuf->byte_buffer = 0;
    strmbuf->buffered_bits = 0;
    strmbuf->zero_bytes = 0;
    strmbuf->emul_cnt = 0;

    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_stream_buffer_init(h264e_hal_vpu_stream *strmbuf, RK_S32 size)
{
    strmbuf->buffer = mpp_calloc(RK_U8, size);

    if (strmbuf->buffer == NULL) {
        mpp_err("allocate stream buffer failed\n");
        return MPP_NOK;
    }
    strmbuf->stream = strmbuf->buffer;
    strmbuf->size = size;
    strmbuf->byte_cnt = 0;
    strmbuf->overflow = 0;
    strmbuf->byte_buffer = 0;
    strmbuf->buffered_bits = 0;
    strmbuf->zero_bytes = 0;
    strmbuf->emul_cnt = 0;

    if (MPP_OK != hal_h264e_vpu_stream_buffer_status(strmbuf)) {
        mpp_err("stream buffer is overflow, while init");
        return MPP_NOK;
    }

    return MPP_OK;
}


void hal_h264e_vpu_stream_put_bits(h264e_hal_vpu_stream *buffer, RK_S32 value, RK_S32 number,
                                   const char *name)
{
    RK_S32 bits;
    RK_U32 byte_buffer = buffer->byte_buffer;
    RK_U8*stream = buffer->stream;

    if (hal_h264e_vpu_stream_buffer_status(buffer) != 0)
        return;

    h264e_hal_log_detail("assemble %s value %x, bits %d\n", name, value, number);

    mpp_assert(value < (1 << number)); //opposite to 'BUG_ON' in kernel
    mpp_assert(number < 25);

    bits = number + buffer->buffered_bits;
    value <<= (32 - bits);
    byte_buffer = byte_buffer | value;

    while (bits > 7) {
        *stream = (RK_U8)(byte_buffer >> 24);

        bits -= 8;
        byte_buffer <<= 8;
        stream++;
        buffer->byte_cnt++;
    }

    buffer->byte_buffer = byte_buffer;
    buffer->buffered_bits = (RK_U8)bits;
    buffer->stream = stream;

    return;
}

void hal_h264e_vpu_stream_put_bits_with_detect(h264e_hal_vpu_stream * buffer, RK_S32 value, RK_S32 number, const char *name)
{
    RK_S32 bits;
    RK_U8 *stream = buffer->stream;
    RK_U32 byte_buffer = buffer->byte_buffer;

    mpp_assert(value < (1 << number));
    mpp_assert(number < 25);

    h264e_hal_log_detail("assemble %s value %x, bits %d\n", name, value, number);

    bits = number + buffer->buffered_bits;
    byte_buffer = byte_buffer | ((RK_U32) value << (32 - bits));

    while (bits > 7) {
        RK_S32 zeroBytes = buffer->zero_bytes;
        RK_S32 byteCnt = buffer->byte_cnt;

        if (hal_h264e_vpu_stream_buffer_status(buffer) != MPP_OK)
            return;

        *stream = (RK_U8) (byte_buffer >> 24);
        byteCnt++;

        if ((zeroBytes == 2) && (*stream < 4)) {
            *stream++ = 3;
            *stream = (RK_U8) (byte_buffer >> 24);
            byteCnt++;
            zeroBytes = 0;
            buffer->emul_cnt++;
        }

        if (*stream == 0)
            zeroBytes++;
        else
            zeroBytes = 0;

        bits -= 8;
        byte_buffer <<= 8;
        stream++;
        buffer->zero_bytes = zeroBytes;
        buffer->byte_cnt = byteCnt;
        buffer->stream = stream;
    }

    buffer->buffered_bits = (RK_U8) bits;
    buffer->byte_buffer = byte_buffer;
}


void hal_h264e_vpu_rbsp_trailing_bits(h264e_hal_vpu_stream * stream)
{
    hal_h264e_vpu_stream_put_bits_with_detect(stream, 1, 1, "rbsp_stop_one_bit");
    if (stream->buffered_bits > 0) {
        hal_h264e_vpu_stream_put_bits_with_detect(stream, 0, 8 - stream->buffered_bits, "bsp_alignment_zero_bit(s)");
    }
}

static void hal_h264e_vpu_write_ue(h264e_hal_vpu_stream *fifo, RK_U32 val,
                                   const char *name)
{
    RK_U32 num_bits = 0;

    val++;
    while (val >> ++num_bits);

    if (num_bits > 12) {
        RK_U32 tmp;

        tmp = num_bits - 1;

        if (tmp > 24) {
            tmp -= 24;
            hal_h264e_vpu_stream_put_bits_with_detect(fifo, 0, 24, name);
        }

        hal_h264e_vpu_stream_put_bits_with_detect(fifo, 0, tmp, name);

        if (num_bits > 24) {
            num_bits -= 24;
            hal_h264e_vpu_stream_put_bits_with_detect(fifo, val >> num_bits, 24, name);
            val = val >> num_bits;
        }

        hal_h264e_vpu_stream_put_bits_with_detect(fifo, val, num_bits, name);
    } else {
        hal_h264e_vpu_stream_put_bits_with_detect(fifo, val, 2 * num_bits - 1, name);
    }
}

static void hal_h264e_vpu_write_se(h264e_hal_vpu_stream *fifo, RK_S32 val, const char *name)
{
    RK_U32 tmp;

    if (val > 0)
        tmp = (RK_U32)(2 * val - 1);
    else
        tmp = (RK_U32)(-2 * val);

    hal_h264e_vpu_write_ue(fifo, tmp, name);
}

static MPP_RET hal_h264e_vpu_nal_start(h264e_hal_vpu_stream * stream, RK_S32 nalRefIdc, rkvenc_nal_unit_type nalUnitType)
{
    hal_h264e_vpu_stream_put_bits(stream, 0,                    8, "leadin_zero_8bits");
    hal_h264e_vpu_stream_put_bits(stream, 0,                    8, "start_code_prefix");
    hal_h264e_vpu_stream_put_bits(stream, 0,                    8, "start_code_prefix");
    hal_h264e_vpu_stream_put_bits(stream, 1,                    8, "start_code_prefix");
    hal_h264e_vpu_stream_put_bits(stream, 0,                    1, "forbidden_zero_bit");
    hal_h264e_vpu_stream_put_bits(stream, nalRefIdc,            2, "nal_ref_idc");
    hal_h264e_vpu_stream_put_bits(stream, (RK_S32)nalUnitType,  5, "nal_unit_type");
    stream->zero_bytes = 0; /* we start new counter for zero bytes */

    return MPP_OK;
}



static MPP_RET hal_h264e_vpu_write_sps(h264e_hal_vpu_stream *stream, h264e_hal_sps *sps)
{
    h264e_hal_debug_enter();

    hal_h264e_vpu_nal_start(stream, 1, RKVENC_NAL_SPS);

    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->i_profile_idc, 8, "profile_idc"); //FIXED: 77, 42
    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_constraint_set0, 1, "constraint_set0_flag"); //E0
    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_constraint_set1, 1, "constraint_set1_flag");
    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_constraint_set2, 1, "constraint_set2_flag");
    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_constraint_set3, 1, "constraint_set3_flag");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, 0, 4, "reserved_zero_4bits");
    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->i_level_idc, 8, "level_idc"); //28

    hal_h264e_vpu_write_ue(stream, sps->i_id, "seq_parameter_set_id"); //8D

    if (sps->i_profile_idc >= 100) { //High profile
        hal_h264e_vpu_write_ue(stream, sps->i_chroma_format_idc, "chroma_format_idc");
        hal_h264e_vpu_write_ue(stream, H264_BIT_DEPTH - 8, "bit_depth_luma_minus8");
        hal_h264e_vpu_write_ue(stream, H264_BIT_DEPTH - 8, "bit_depth_chroma_minus8");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_qpprime_y_zero_transform_bypass, 1, "qpprime_y_zero_transform_bypass_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, 0, 1, "seq_scaling_matrix_present_flag");
    }

    hal_h264e_vpu_write_ue(stream, sps->i_log2_max_frame_num - 4, "log2_max_frame_num_minus4");

    hal_h264e_vpu_write_ue(stream, sps->i_poc_type, "pic_order_cnt_type"); //68 16

    hal_h264e_vpu_write_ue(stream, sps->i_num_ref_frames, "num_ref_frames");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_gaps_in_frame_num_value_allowed, 1, "gaps_in_frame_num_value_allowed_flag");

    hal_h264e_vpu_write_ue(stream, sps->i_mb_width - 1, "pic_width_in_mbs_minus1");

    hal_h264e_vpu_write_ue(stream, sps->i_mb_height - 1, "pic_height_in_map_units_minus1"); //09 64

    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_frame_mbs_only, 1, "frame_mbs_only_flag");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_direct8x8_inference, 1, "direct_8x8_inference_flag");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_crop, 1, "frame_cropping_flag");
    if (sps->b_crop) {
        hal_h264e_vpu_write_ue(stream, sps->crop.i_left / 2, "frame_crop_left_offset");
        hal_h264e_vpu_write_ue(stream, sps->crop.i_right / 2, "frame_crop_right_offset");
        hal_h264e_vpu_write_ue(stream, sps->crop.i_top / 2, "frame_crop_top_offset");
        hal_h264e_vpu_write_ue(stream, sps->crop.i_bottom / 2, "frame_crop_bottom_offset");
    }

    hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->b_vui,     1, "vui_parameters_present_flag");
    if (sps->b_vui) {
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_aspect_ratio_info_present,         1, "aspect_ratio_info_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_overscan_info_present,             1, "overscan_info_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_signal_type_present,               1, "video_signal_type_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_chroma_loc_info_present,           1, "chroma_loc_info_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_timing_info_present,               1, "timing_info_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_num_units_in_tick >> 16,           16, "num_units_in_tick msb");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_num_units_in_tick & 0xffff,        16, "num_units_in_tick lsb");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_time_scale >> 16,                  16, "time_scale msb");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_time_scale & 0xffff,               16, "time_scale lsb");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_fixed_frame_rate,                  1, "fixed_frame_rate_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_nal_hrd_parameters_present,        1, "nal_hrd_parameters_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_vcl_hrd_parameters_present,        1, "vcl_hrd_parameters_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_pic_struct_present,                1, "pic_struct_present_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_bitstream_restriction,             1, "bit_stream_restriction_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.b_motion_vectors_over_pic_boundaries, 1, "motion_vectors_over_pic_boundaries");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_max_bytes_per_pic_denom,           1, "max_bytes_per_pic_denom");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_max_bits_per_mb_denom,             1, "max_bits_per_mb_denom");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_log2_max_mv_length_horizontal,     7, "log2_mv_length_horizontal");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_log2_max_mv_length_vertical,       5, "log2_mv_length_vertical");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_num_reorder_frames,                1, "num_reorder_frames");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, sps->vui.i_max_dec_frame_buffering,           3, "max_dec_frame_buffering");
    }

    hal_h264e_vpu_rbsp_trailing_bits(stream);

    h264e_hal_log_detail("sps write size: %d bytes", stream->byte_cnt);

    h264e_hal_debug_leave();

    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_write_pps(h264e_hal_vpu_stream *stream, h264e_hal_pps *pps)
{
    h264e_hal_debug_enter();

    hal_h264e_vpu_nal_start(stream, 1, RKVENC_NAL_PPS);

    hal_h264e_vpu_write_ue(stream, pps->i_id, "pic_parameter_set_id");
    hal_h264e_vpu_write_ue(stream, pps->i_sps_id, "seq_parameter_set_id");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_cabac, 1, "entropy_coding_mode_flag");
    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_pic_order, 1, "pic_order_present_flag");

    hal_h264e_vpu_write_ue(stream, pps->i_num_slice_groups - 1, "num_slice_groups_minus1");
    hal_h264e_vpu_write_ue(stream, pps->i_num_ref_idx_l0_default_active - 1, "num_ref_idx_l0_active_minus1");
    hal_h264e_vpu_write_ue(stream, pps->i_num_ref_idx_l1_default_active - 1, "num_ref_idx_l1_active_minus1");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_weighted_pred, 1, "weighted_pred_flag");
    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->i_weighted_bipred_idc, 2, "weighted_bipred_idc");

    hal_h264e_vpu_write_se(stream, pps->i_pic_init_qp - 26, "pic_init_qp_minus26");
    hal_h264e_vpu_write_se(stream, pps->i_pic_init_qs - 26, "pic_init_qs_minus26");
    hal_h264e_vpu_write_se(stream, pps->i_chroma_qp_index_offset, "chroma_qp_index_offset");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_deblocking_filter_control, 1, "deblocking_filter_control_present_flag");
    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_constrained_intra_pred, 1, "constrained_intra_pred_flag");

    hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_redundant_pic_cnt, 1, "redundant_pic_cnt_present_flag");

    if (pps->b_transform_8x8_mode) {
        hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_transform_8x8_mode, 1, "transform_8x8_mode_flag");
        hal_h264e_vpu_stream_put_bits_with_detect(stream, pps->b_cqm_preset, 1, "pic_scaling_matrix_present_flag");
        hal_h264e_vpu_write_se(stream, pps->i_chroma_qp_index_offset, "chroma_qp_index_offset");
    }

    hal_h264e_vpu_rbsp_trailing_bits(stream);

    h264e_hal_log_detail("pps write size: %d bytes", stream->byte_cnt);

    h264e_hal_debug_leave();

    return MPP_OK;
}

static void hal_h264e_vpu_set_sps(h264e_hal_sps *sps, h264e_control_extra_info_cfg *cfg)
{
    sps->i_profile_idc = cfg->profile_idc;   /* 66 = baseline, 77 = main, 100 = high */
    sps->b_constraint_set0 = 1;
    sps->b_constraint_set1 = 1;
    sps->b_constraint_set2 = 1;
    sps->b_constraint_set3 = 0;

    sps->i_level_idc = cfg->level_idc;
    sps->i_id = 0;
    sps->i_log2_max_frame_num = 16;
    sps->i_poc_type = 2;

    sps->i_num_ref_frames = 1;
    sps->b_gaps_in_frame_num_value_allowed = 0;
    sps->i_mb_width = ( cfg->pic_luma_width + 15 ) / 16;
    sps->i_mb_height = ( cfg->pic_luma_height + 15 ) / 16;
    sps->b_frame_mbs_only = 1;
    sps->b_direct8x8_inference = 1;
    sps->i_chroma_format_idc = 1; //YUV420

    sps->b_vui = 1;

    sps->vui.b_fullrange = 0;
    sps->vui.i_sar_width = 0;
    sps->vui.i_sar_height = 0;
    sps->vui.b_aspect_ratio_info_present = 0;
    sps->vui.b_overscan_info_present = 0;
    sps->vui.b_signal_type_present = 0;
    sps->vui.b_chroma_loc_info_present = 0;

    sps->vui.b_timing_info_present = 1;
    sps->vui.i_num_units_in_tick = 1;
    sps->vui.i_time_scale = cfg->frame_rate * 2;
    sps->vui.b_fixed_frame_rate = 0;

    sps->vui.b_nal_hrd_parameters_present = 0;
    sps->vui.b_vcl_hrd_parameters_present = 0;
    sps->vui.b_pic_struct_present = 0;

    sps->vui.b_bitstream_restriction = 1;
    sps->vui.b_motion_vectors_over_pic_boundaries = 1;
    sps->vui.i_max_bytes_per_pic_denom = 1;
    sps->vui.i_max_bits_per_mb_denom = 1;
    sps->vui.i_log2_max_mv_length_horizontal = 8;
    sps->vui.i_log2_max_mv_length_vertical = 7;
    sps->vui.i_num_reorder_frames = 1;
    sps->vui.i_max_dec_frame_buffering = 2;

    if (cfg->pic_luma_width % 16 || cfg->pic_luma_height % 16 ) {
        RK_U32 fill_right = sps->i_mb_width * 16 - cfg->pic_luma_width;
        RK_U32 fill_bottom = sps->i_mb_height * 16 - cfg->pic_luma_height;
        sps->b_crop = 1;
        sps->crop.i_right  = fill_right;
        sps->crop.i_bottom = fill_bottom;
        sps->crop.i_left = 0;
        sps->crop.i_top = 0;
    } else {
        sps->b_crop = 0;
        sps->crop.i_right  = 0;
        sps->crop.i_bottom = 0;
        sps->crop.i_left = 0;
        sps->crop.i_top = 0;
    }

    /* only for backup, exclued in read SPS */
    sps->keyframe_max_interval = cfg->keyframe_max_interval;
}

static void hal_h264e_vpu_set_pps(h264e_hal_pps *pps, h264e_control_extra_info_cfg *cfg)
{
    pps->i_id = 0;
    pps->i_sps_id = 0;
    pps->b_cabac = 0;
    pps->b_pic_order = 0;
    pps->i_num_slice_groups = 1;
    pps->i_num_ref_idx_l0_default_active = 1;
    pps->i_num_ref_idx_l1_default_active = 1;
    pps->b_weighted_pred = 0;
    pps->i_weighted_bipred_idc = 0;
    pps->i_pic_init_qp = cfg->pic_init_qp;
    pps->i_pic_init_qs = cfg->pic_init_qp;
    pps->i_chroma_qp_index_offset = cfg->chroma_qp_index_offset;
    pps->b_deblocking_filter_control = 1;
    pps->b_constrained_intra_pred = 0;
    pps->b_redundant_pic_cnt = 0;
    pps->b_transform_8x8_mode = cfg->transform8x8_mode;

    (void)cfg;
}

static MPP_RET hal_h264e_vpu_init_extra_info(void *extra_info)
{
    h264e_hal_vpu_extra_info *info = (h264e_hal_vpu_extra_info *)extra_info;
    h264e_hal_vpu_stream *sps_stream = &info->sps_stream;
    h264e_hal_vpu_stream *pps_stream = &info->pps_stream;

    if (MPP_OK != hal_h264e_vpu_stream_buffer_init(sps_stream, 128)) {
        mpp_err("sps stream sw buf init failed");
        return MPP_NOK;
    }
    if (MPP_OK != hal_h264e_vpu_stream_buffer_init(pps_stream, 128)) {
        mpp_err("pps stream sw buf init failed");
        return MPP_NOK;
    }

    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_deinit_extra_info(void *extra_info)
{
    h264e_hal_vpu_extra_info *info = (h264e_hal_vpu_extra_info *)extra_info;
    h264e_hal_vpu_stream *sps_stream = &info->sps_stream;
    h264e_hal_vpu_stream *pps_stream = &info->pps_stream;

    MPP_FREE(sps_stream->buffer);
    MPP_FREE(pps_stream->buffer);

    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_set_extra_info(h264e_hal_context *ctx, void *param)
{
    h264e_control_extra_info_cfg *cfg = (h264e_control_extra_info_cfg *)param;
    h264e_hal_vpu_extra_info *info = (h264e_hal_vpu_extra_info *)ctx->extra_info;
    h264e_hal_vpu_stream *sps_stream = &info->sps_stream;
    h264e_hal_vpu_stream *pps_stream = &info->pps_stream;
    h264e_hal_sps *sps = &info->sps;
    h264e_hal_pps *pps = &info->pps;
    h264e_hal_debug_enter();

    info->sei.extra_info_cfg = *cfg;
    hal_h264e_vpu_stream_buffer_reset(sps_stream);
    hal_h264e_vpu_stream_buffer_reset(pps_stream);

    hal_h264e_vpu_set_sps(sps, cfg);
    hal_h264e_vpu_set_pps(pps, cfg);

    hal_h264e_vpu_write_sps(sps_stream, sps);
    hal_h264e_vpu_write_pps(pps_stream, pps);

    h264e_hal_debug_leave();

    return MPP_OK;
}

static RK_S32 exp_golomb_signed(RK_S32 val)
{
    RK_S32 tmp = 0;

    if (val > 0)
        val = 2 * val;
    else
        val = -2 * val + 1;

    while (val >> ++tmp)
        ;

    return tmp * 2 - 1;
}


MPP_RET hal_h264e_vpu_init(void *hal, MppHalCfg *cfg)
{
    h264e_hal_context *ctx = (h264e_hal_context *)hal;
    h264e_hal_debug_enter();

    ctx->int_cb = cfg->hal_int_cb;
    ctx->regs = mpp_calloc(h264e_vpu_reg_set, 1);
    ctx->buffers = mpp_calloc(h264e_hal_vpu_buffers, 1);
    ctx->extra_info = mpp_calloc(h264e_hal_vpu_extra_info, 1);
    ctx->dump_files = mpp_calloc(h264e_hal_vpu_dump_files, 1);
    ctx->param_buf  = mpp_calloc_size(void,  H264E_EXTRA_INFO_BUF_SIZE);
    mpp_packet_init(&ctx->packeted_param, ctx->param_buf, H264E_EXTRA_INFO_BUF_SIZE);

    hal_h264e_vpu_init_extra_info(ctx->extra_info);
#ifdef H264E_DUMP_DATA_TO_FILE
    hal_h264e_vpu_open_dump_files(ctx->dump_files);
#endif

    ctx->vpu_socket = -1;
    ctx->vpu_client = VPU_ENC;
    h264e_hal_log_detail("vpu client: %d", ctx->vpu_client);
#ifdef RKPLATFORM
    if (ctx->vpu_socket <= 0) {
        ctx->vpu_socket = VPUClientInit(ctx->vpu_client);
        if (ctx->vpu_socket <= 0) {
            mpp_err("get vpu_socket(%d) <=0, failed. \n", ctx->vpu_socket);
            return MPP_ERR_UNKNOW;
        } else {
            VPUHwEncConfig_t hwCfg;
            h264e_hal_log_detail("get vpu_socket(%d), success. \n", ctx->vpu_socket);
            memset(&hwCfg, 0, sizeof(VPUHwEncConfig_t));
            if (VPUClientGetHwCfg(ctx->vpu_socket, (RK_U32*)&hwCfg, sizeof(hwCfg))) {
                mpp_err("h264enc # Get HwCfg failed, release vpu\n");
                VPUClientRelease(ctx->vpu_socket);
                return MPP_NOK;
            }
        }
    }
#endif

    h264e_hal_debug_leave();
    return MPP_OK;
}

MPP_RET hal_h264e_vpu_deinit(void *hal)
{
    h264e_hal_context *ctx = (h264e_hal_context *)hal;
    h264e_hal_debug_enter();

    MPP_FREE(ctx->regs);
    MPP_FREE(ctx->param_buf);

    if (ctx->extra_info) {
        hal_h264e_vpu_deinit_extra_info(ctx->extra_info);
        MPP_FREE(ctx->extra_info);
    }

    if (ctx->packeted_param) {
        mpp_packet_deinit(&ctx->packeted_param);
        ctx->packeted_param = NULL;
    }

    if (ctx->buffers) {
        hal_h264e_vpu_free_buffers(ctx);
        MPP_FREE(ctx->buffers);
    }

#ifdef H264E_DUMP_DATA_TO_FILE
    if (ctx->dump_files) {
        hal_h264e_vpu_close_dump_files(ctx->dump_files);
        MPP_FREE(ctx->dump_files);
    }
#endif

#ifdef RKPLATFORM
    if (ctx->vpu_socket <= 0) {
        mpp_err("invalid vpu socket: %d", ctx->vpu_socket);
        return MPP_NOK;
    }

    if (VPU_SUCCESS != VPUClientRelease(ctx->vpu_socket)) {
        mpp_err("VPUClientRelease failed");
        return MPP_ERR_VPUHW;
    }
#endif

    h264e_hal_debug_leave();
    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_validate_syntax(h264e_syntax *syn, h264e_hal_vpu_csp_info *src_fmt)
{
    h264e_hal_debug_enter();

    /* validate */
    H264E_HAL_VALIDATE_GT(syn->output_strm_limit_size, "output_strm_limit_size", 0);

    /* adjust */
    syn->output_strm_limit_size /= 8; /* 64-bit addresses */
    syn->output_strm_limit_size &= (~0x07);  /* 8 multiple size */
    *src_fmt = hal_h264e_vpu_convert_csp(syn->input_image_format);
    syn->input_image_format = src_fmt->fmt;

    H264E_HAL_VALIDATE_NEQ(syn->input_image_format, "input_image_format", H264E_VPU_CSP_NONE);

    h264e_hal_debug_leave();
    return MPP_OK;
}


MPP_RET hal_h264e_vpu_gen_regs(void *hal, HalTaskInfo *task)
{
    RK_S32 scaler = 0, i = 0;
    RK_U32 val = 0, skip_penalty = 0;
    RK_U32 overfill_r = 0, overfill_b = 0;
    RK_U32 first_free_bit = 0, constrained_intra_prediction = 0;
    RK_U8 dmv_penalty[128] = {0};
    RK_U8 dmv_qpel_penalty[128] = {0};
    RK_U32 diff_mv_penalty[3] = {0};
    h264e_hal_vpu_csp_info src_fmt;

    h264e_hal_context *ctx = (h264e_hal_context *)hal;
    RK_U32 *reg = (RK_U32 *)ctx->regs;
    h264e_syntax *syn = (h264e_syntax *)task->enc.syntax.data;

    RK_U32 mbs_in_row = (syn->pic_luma_width + 15) / 16;
    RK_U32 mbs_in_col = (syn->pic_luma_height + 15) / 16;
    RK_U32 prev_mode_favor = h264_prev_mode_favor[syn->qp];
    h264e_hal_vpu_buffers *bufs = (h264e_hal_vpu_buffers *)ctx->buffers;
    RK_U32 buf2_idx = ctx->frame_cnt % 2;
    h264e_hal_vpu_extra_info *extra_info = (h264e_hal_vpu_extra_info *)ctx->extra_info;
    h264e_hal_pps *pps = &extra_info->pps;
    h264e_hal_debug_enter();

    if (ctx->frame_cnt == 0) {
        if (MPP_OK != hal_h264e_vpu_allocate_buffers(ctx, syn)) {
            h264e_hal_log_err("hal_h264e_vpu_allocate_buffers failed, free now");
            hal_h264e_vpu_free_buffers(ctx);
        }
    }

#ifdef H264E_DUMP_DATA_TO_FILE
    hal_h264e_vpu_dump_mpp_syntax_in(syn, ctx);
#endif
    if (MPP_OK != hal_h264e_vpu_validate_syntax(syn, &src_fmt)) {
        h264e_hal_log_err("hal_h264e_vpu_validate_syntax failed");
    }
    memset(reg, 0, sizeof(h264e_vpu_reg_set));

    h264e_hal_log_detail("frame %d generate regs now", ctx->frame_cnt);

    /* If frame encode type for current frame is intra, write sps pps to
       the output buffer */
    H264E_HAL_SET_REG(reg, VEPU_REG_STR_BUF_LIMIT, syn->output_strm_limit_size);

    /*
     * The hardware needs only the value for luma plane, because
     * values of other planes are calculated internally based on
     * format setting.
     */
    val = VEPU_REG_INTRA_AREA_TOP(mbs_in_col)
          | VEPU_REG_INTRA_AREA_BOTTOM(mbs_in_col)
          | VEPU_REG_INTRA_AREA_LEFT(mbs_in_row)
          | VEPU_REG_INTRA_AREA_RIGHT(mbs_in_row);
    H264E_HAL_SET_REG(reg, VEPU_REG_INTRA_AREA_CTRL, val); //FIXED
    H264E_HAL_SET_REG(reg, VEPU_REG_STR_HDR_REM_MSB, 0);
    H264E_HAL_SET_REG(reg, VEPU_REG_STR_HDR_REM_LSB, 0);


    val = VEPU_REG_AXI_CTRL_READ_ID(0);
    val |= VEPU_REG_AXI_CTRL_WRITE_ID(0);
    val |= VEPU_REG_AXI_CTRL_BURST_LEN(16);
    val |= VEPU_REG_AXI_CTRL_INCREMENT_MODE(0);
    val |= VEPU_REG_AXI_CTRL_BIRST_DISCARD(0);
    H264E_HAL_SET_REG(reg, VEPU_REG_AXI_CTRL, val);

    H264E_HAL_SET_REG(reg, VEPU_QP_ADJUST_MAD_DELTA_ROI, syn->mad_qp_delta);

    val = 0;
    if (mbs_in_row * mbs_in_col > 3600)
        val = VEPU_REG_DISABLE_QUARTER_PIXEL_MV;
    val |= VEPU_REG_CABAC_INIT_IDC(syn->cabac_init_idc);
    if (syn->enable_cabac)
        val |= VEPU_REG_ENTROPY_CODING_MODE;
    if (pps->b_transform_8x8_mode)
        val |= VEPU_REG_H264_TRANS8X8_MODE;
    if (syn->h264_inter4x4_disabled)
        val |= VEPU_REG_H264_INTER4X4_MODE;
    /*reg |= VEPU_REG_H264_STREAM_MODE;*/
    val |= VEPU_REG_H264_SLICE_SIZE(syn->slice_size_mb_rows);
    H264E_HAL_SET_REG(reg, VEPU_REG_ENC_CTRL0, val);

    scaler = H264E_HAL_MAX(1, 200 / (mbs_in_row + mbs_in_col));
    skip_penalty = H264E_HAL_MIN(255, h264_skip_sad_penalty[syn->qp] * scaler);
    if (syn->pic_luma_width & 0x0f)
        overfill_r = (16 - (syn->pic_luma_width & 0x0f) ) / 4;
    if (syn->pic_luma_height & 0x0f)
        overfill_b = 16 - (syn->pic_luma_height & 0x0f);
    val = VEPU_REG_STREAM_START_OFFSET(first_free_bit) |
          VEPU_REG_SKIP_MACROBLOCK_PENALTY(skip_penalty) |
          VEPU_REG_IN_IMG_CTRL_OVRFLR_D4(overfill_r) |
          VEPU_REG_IN_IMG_CTRL_OVRFLB(overfill_b);
    H264E_HAL_SET_REG(reg, VEPU_REG_ENC_OVER_FILL_STRM_OFFSET, val);


    val = VEPU_REG_IN_IMG_CHROMA_OFFSET(0)
          | VEPU_REG_IN_IMG_LUMA_OFFSET(0)
          | VEPU_REG_IN_IMG_CTRL_ROW_LEN(syn->pic_luma_width);
    H264E_HAL_SET_REG(reg, VEPU_REG_INPUT_LUMA_INFO, val);

    val = VEPU_REG_CHECKPOINT_CHECK1(syn->cp_target[0])
          | VEPU_REG_CHECKPOINT_CHECK0(syn->cp_target[1]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHECKPOINT(0), val);

    val = VEPU_REG_CHECKPOINT_CHECK1(syn->cp_target[2])
          | VEPU_REG_CHECKPOINT_CHECK0(syn->cp_target[3]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHECKPOINT(1), val);

    val = VEPU_REG_CHECKPOINT_CHECK1(syn->cp_target[4])
          | VEPU_REG_CHECKPOINT_CHECK0(syn->cp_target[5]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHECKPOINT(2), val);

    val = VEPU_REG_CHECKPOINT_CHECK1(syn->cp_target[6])
          | VEPU_REG_CHECKPOINT_CHECK0(syn->cp_target[7]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHECKPOINT(3), val);

    val = VEPU_REG_CHECKPOINT_CHECK1(syn->cp_target[8])
          | VEPU_REG_CHECKPOINT_CHECK0(syn->cp_target[9]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHECKPOINT(4), val);

    val = VEPU_REG_CHKPT_WORD_ERR_CHK1(syn->target_error[0])
          | VEPU_REG_CHKPT_WORD_ERR_CHK0(syn->target_error[1]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHKPT_WORD_ERR(0), val);

    val = VEPU_REG_CHKPT_WORD_ERR_CHK1(syn->target_error[2])
          | VEPU_REG_CHKPT_WORD_ERR_CHK0(syn->target_error[3]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHKPT_WORD_ERR(1), val);

    val = VEPU_REG_CHKPT_WORD_ERR_CHK1(syn->target_error[4])
          | VEPU_REG_CHKPT_WORD_ERR_CHK0(syn->target_error[5]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHKPT_WORD_ERR(2), val);

    val = VEPU_REG_CHKPT_DELTA_QP_CHK6(syn->delta_qp[6])
          | VEPU_REG_CHKPT_DELTA_QP_CHK5(syn->delta_qp[5])
          | VEPU_REG_CHKPT_DELTA_QP_CHK4(syn->delta_qp[4])
          | VEPU_REG_CHKPT_DELTA_QP_CHK3(syn->delta_qp[3])
          | VEPU_REG_CHKPT_DELTA_QP_CHK2(syn->delta_qp[2])
          | VEPU_REG_CHKPT_DELTA_QP_CHK1(syn->delta_qp[1])
          | VEPU_REG_CHKPT_DELTA_QP_CHK0(syn->delta_qp[0]);
    H264E_HAL_SET_REG(reg, VEPU_REG_CHKPT_DELTA_QP, val);

    val = VEPU_REG_MAD_THRESHOLD(syn->mad_threshold)
          | VEPU_REG_IN_IMG_CTRL_FMT(src_fmt.fmt)
          | VEPU_REG_IN_IMG_ROTATE_MODE(0)
          | VEPU_REG_SIZE_TABLE_PRESENT; //FIXED
    H264E_HAL_SET_REG(reg, VEPU_REG_ENC_CTRL1, val);

    val = VEPU_REG_INTRA16X16_MODE(h264_intra16_favor[syn->qp])
          | VEPU_REG_INTER_MODE(h264_inter_favor[syn->qp]);
    H264E_HAL_SET_REG(reg, VEPU_REG_INTRA_INTER_MODE, val);

    val = VEPU_REG_PPS_INIT_QP(syn->pic_init_qp)
          | VEPU_REG_SLICE_FILTER_ALPHA(syn->slice_alpha_offset)
          | VEPU_REG_SLICE_FILTER_BETA(syn->slice_beta_offset)
          | VEPU_REG_CHROMA_QP_OFFSET(syn->chroma_qp_index_offset)
          | VEPU_REG_IDR_PIC_ID(syn->idr_pic_id);

    if (syn->filter_disable)
        val |= VEPU_REG_FILTER_DISABLE;

    if (constrained_intra_prediction)
        val |= VEPU_REG_CONSTRAINED_INTRA_PREDICTION;
    H264E_HAL_SET_REG(reg, VEPU_REG_ENC_CTRL2, val);

    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_NEXT_PIC, 0);
    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_MV_OUT, 0);
    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_CABAC_TBL, mpp_buffer_get_fd(bufs->hw_cabac_table_buf));

    val = VEPU_REG_ROI1_TOP_MB(mbs_in_col)
          | VEPU_REG_ROI1_BOTTOM_MB(mbs_in_col)
          | VEPU_REG_ROI1_LEFT_MB(mbs_in_row)
          | VEPU_REG_ROI1_RIGHT_MB(mbs_in_row);
    H264E_HAL_SET_REG(reg, VEPU_REG_ROI1, val); //FIXED

    val = VEPU_REG_ROI2_TOP_MB(mbs_in_col)
          | VEPU_REG_ROI2_BOTTOM_MB(mbs_in_col)
          | VEPU_REG_ROI2_LEFT_MB(mbs_in_row)
          | VEPU_REG_ROI2_RIGHT_MB(mbs_in_row);
    H264E_HAL_SET_REG(reg, VEPU_REG_ROI2, val); //FIXED
    H264E_HAL_SET_REG(reg, VEPU_REG_STABLILIZATION_OUTPUT, 0);

    val = VEPU_REG_RGB2YUV_CONVERSION_COEFB(syn->color_conversion_coeff_b)
          | VEPU_REG_RGB2YUV_CONVERSION_COEFA(syn->color_conversion_coeff_a);
    H264E_HAL_SET_REG(reg, VEPU_REG_RGB2YUV_CONVERSION_COEF1, val); //FIXED

    val = VEPU_REG_RGB2YUV_CONVERSION_COEFE(syn->color_conversion_coeff_e)
          | VEPU_REG_RGB2YUV_CONVERSION_COEFC(syn->color_conversion_coeff_c);
    H264E_HAL_SET_REG(reg, VEPU_REG_RGB2YUV_CONVERSION_COEF2, val); //FIXED

    val = VEPU_REG_RGB2YUV_CONVERSION_COEFF(syn->color_conversion_coeff_f);
    H264E_HAL_SET_REG(reg, VEPU_REG_RGB2YUV_CONVERSION_COEF3, val); //FIXED

    val = VEPU_REG_RGB_MASK_B_MSB(src_fmt.b_mask_msb)
          | VEPU_REG_RGB_MASK_G_MSB(src_fmt.g_mask_msb)
          | VEPU_REG_RGB_MASK_R_MSB(src_fmt.r_mask_msb);
    H264E_HAL_SET_REG(reg, VEPU_REG_RGB_MASK_MSB, val); //FIXED

    diff_mv_penalty[0] = h264_diff_mv_penalty4p[syn->qp];
    diff_mv_penalty[1] = h264_diff_mv_penalty[syn->qp];
    diff_mv_penalty[2] = h264_diff_mv_penalty[syn->qp];

    val = VEPU_REG_1MV_PENALTY(diff_mv_penalty[1])
          | VEPU_REG_QMV_PENALTY(diff_mv_penalty[2])
          | VEPU_REG_4MV_PENALTY(diff_mv_penalty[0]);

    val |= VEPU_REG_SPLIT_MV_MODE_EN;
    H264E_HAL_SET_REG(reg, VEPU_REG_MV_PENALTY, val);

    val = VEPU_REG_H264_LUMA_INIT_QP(syn->qp)
          | VEPU_REG_H264_QP_MAX(syn->qp_max)
          | VEPU_REG_H264_QP_MIN(syn->qp_min)
          | VEPU_REG_H264_CHKPT_DISTANCE(syn->cp_distance_mbs);
    H264E_HAL_SET_REG(reg, VEPU_REG_QP_VAL, val);

    val = VEPU_REG_ZERO_MV_FAVOR_D2(10);
    H264E_HAL_SET_REG(reg, VEPU_REG_MVC_RELATE, val);

    val = VEPU_REG_OUTPUT_SWAP32
          | VEPU_REG_OUTPUT_SWAP16
          | VEPU_REG_OUTPUT_SWAP8
          | VEPU_REG_INPUT_SWAP8
          | VEPU_REG_INPUT_SWAP16
          | VEPU_REG_INPUT_SWAP32;
    H264E_HAL_SET_REG(reg, VEPU_REG_DATA_ENDIAN, val);

    val = VEPU_REG_PPS_ID(syn->pps_id)
          | VEPU_REG_INTRA_PRED_MODE(prev_mode_favor)
          | VEPU_REG_FRAME_NUM(syn->frame_num);
    H264E_HAL_SET_REG(reg, VEPU_REG_ENC_CTRL3, val);

    val = VEPU_REG_INTERRUPT_TIMEOUT_EN;
    H264E_HAL_SET_REG(reg, VEPU_REG_INTERRUPT, val);

    for (i = 0; i < 128; i++) {
        dmv_penalty[i] = i;
        dmv_qpel_penalty[i] = H264E_HAL_MIN(255, exp_golomb_signed(i));
    }

    for (i = 0; i < 128; i += 4) {
        val = VEPU_REG_DMV_PENALTY_TABLE_BIT(dmv_penalty[i], 3);
        val |= VEPU_REG_DMV_PENALTY_TABLE_BIT(dmv_penalty[i + 1], 2);
        val |= VEPU_REG_DMV_PENALTY_TABLE_BIT(dmv_penalty[i + 2], 1);
        val |= VEPU_REG_DMV_PENALTY_TABLE_BIT(dmv_penalty[i + 3], 0);
        H264E_HAL_SET_REG(reg, VEPU_REG_DMV_PENALTY_TBL(i / 4), val);

        val = VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
                  dmv_qpel_penalty[i], 3);
        val |= VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
                   dmv_qpel_penalty[i + 1], 2);
        val |= VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
                   dmv_qpel_penalty[i + 2], 1);
        val |= VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
                   dmv_qpel_penalty[i + 3], 0);
        H264E_HAL_SET_REG(reg, VEPU_REG_DMV_Q_PIXEL_PENALTY_TBL(i / 4), val);
    }

    /* set buffers addr */
    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_IN_LUMA, syn->input_luma_addr);
    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_IN_CB, syn->input_cb_addr);
    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_IN_CR, syn->input_cr_addr);

    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_OUTPUT_STREAM, syn->output_strm_addr);
    H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_OUTPUT_CTRL, mpp_buffer_get_fd(bufs->hw_nal_size_table_buf));

    {
        RK_S32 recon_chroma_addr = 0, ref_chroma_addr = 0;
        RK_U32 frame_luma_size = mbs_in_col * mbs_in_row * 256;
        RK_S32 recon_luma_addr = mpp_buffer_get_fd(bufs->hw_rec_buf[buf2_idx]);
        RK_S32 ref_luma_addr = mpp_buffer_get_fd(bufs->hw_rec_buf[1 - buf2_idx]);
        if (VPUClientGetIOMMUStatus() > 0) {
            recon_chroma_addr = recon_luma_addr | (frame_luma_size << 10);
            ref_chroma_addr   = ref_luma_addr   | (frame_luma_size << 10);
        } else {
            recon_chroma_addr = recon_luma_addr + frame_luma_size;
            ref_chroma_addr   = ref_luma_addr   + frame_luma_size ;
        }
        H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_REC_LUMA, recon_luma_addr);
        H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_REC_CHROMA, recon_chroma_addr);
        H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_REF_LUMA, ref_luma_addr);
        H264E_HAL_SET_REG(reg, VEPU_REG_ADDR_REF_CHROMA , ref_chroma_addr);
    }


    /* set important encode mode info */
    val = VEPU_REG_MB_HEIGHT(mbs_in_col)
          | VEPU_REG_MB_WIDTH(mbs_in_row)
          | VEPU_REG_PIC_TYPE(syn->frame_coding_type)
          | VEPU_REG_ENCODE_FORMAT(3)
          | VEPU_REG_ENCODE_ENABLE;
    H264E_HAL_SET_REG(reg, VEPU_REG_ENCODE_START, val);


#ifdef H264E_DUMP_DATA_TO_FILE
    hal_h264e_vpu_dump_mpp_reg_in(ctx);
#endif

    ctx->frame_cnt++;
    h264e_hal_debug_leave();
    return MPP_OK;
}

MPP_RET hal_h264e_vpu_start(void *hal, HalTaskInfo *task)
{
    h264e_hal_context *ctx = (h264e_hal_context *)hal;
    (void)task;
    h264e_hal_debug_enter();
#ifdef RKPLATFORM
    if (ctx->vpu_socket > 0) {
        RK_U32 *p_regs = (RK_U32 *)ctx->regs;
        h264e_hal_log_detail("vpu client is sending %d regs", VEPU_H264E_NUM_REGS);
        if (MPP_OK != VPUClientSendReg(ctx->vpu_socket, p_regs, VEPU_H264E_NUM_REGS)) {
            mpp_err("VPUClientSendReg Failed!!!");
            return MPP_ERR_VPUHW;
        } else {
            h264e_hal_log_detail("VPUClientSendReg successfully!");
        }
    } else {
        mpp_err("invalid vpu socket: %d", ctx->vpu_socket);
        return MPP_NOK;
    }
#endif
    (void)ctx;
    h264e_hal_debug_leave();

    return MPP_OK;
}

static MPP_RET hal_h264e_vpu_set_feedback(h264e_feedback *fb, h264e_vpu_reg_set *reg)
{
    RK_S32 i = 0;
    RK_U32 cpt_prev = 0, overflow = 0;
    RK_U32 cpt_idx = VEPU_REG_CHECKPOINT(0) / 4;
    RK_U32 *reg_val = (RK_U32 *)reg;
    fb->hw_status = reg_val[VEPU_REG_INTERRUPT / 4];
    fb->qp_sum = VEPU_REG_QP_SUM(reg_val[VEPU_REG_QP_SUM_DIV2 / 4]);
    fb->mad_count = VEPU_REG_MB_CNT_SET(reg_val[VEPU_REG_MB_CTRL / 4]);
    fb->rlc_count = VEPU_REG_RLC_SUM_OUT(reg_val[VEPU_REG_RLC_SUM / 4]);
    fb->out_strm_size = reg_val[VEPU_REG_STR_BUF_LIMIT / 4] / 8;
    for (i = 0; i < 10; i++) {
        RK_U32 cpt = VEPU_REG_CHECKPOINT_RESULT(reg_val[cpt_idx]);
        if (cpt < cpt_prev)
            overflow += (1 << 21);
        fb->cp[i] = cpt + overflow;
        cpt_idx += (i & 1);
    }

    return MPP_OK;
}

MPP_RET hal_h264e_vpu_wait(void *hal, HalTaskInfo *task)
{
    h264e_hal_context *ctx = (h264e_hal_context *)hal;
    h264e_vpu_reg_set *reg_out = (h264e_vpu_reg_set *)ctx->regs;
    IOInterruptCB int_cb = ctx->int_cb;
    h264e_feedback *fb = &ctx->feedback;
    (void)task;
    h264e_hal_debug_enter();

#ifdef RKPLATFORM
    if (ctx->vpu_socket > 0) {
        VPU_CMD_TYPE cmd = 0;
        RK_S32 length = 0;
        RK_S32 hw_ret = VPUClientWaitResult(ctx->vpu_socket, (RK_U32 *)reg_out,
                                            VEPU_H264E_NUM_REGS, &cmd, &length);

        h264e_hal_log_detail("VPUClientWaitResult: ret %d, cmd %d, len %d\n", hw_ret, cmd, length);


        if ((VPU_SUCCESS != hw_ret) || (cmd != VPU_SEND_CONFIG_ACK_OK))
            mpp_err("hardware wait error");

        if (hw_ret != MPP_OK) {
            mpp_err("hardware returns error:%d", hw_ret);
            return MPP_ERR_VPUHW;
        }
    } else {
        mpp_err("invalid vpu socket: %d", ctx->vpu_socket);
        return MPP_NOK;
    }
#endif

    if (int_cb.callBack) {
        hal_h264e_vpu_set_feedback(fb, reg_out);
#ifdef H264E_DUMP_DATA_TO_FILE
        hal_h264e_vpu_dump_mpp_feedback(ctx);
#endif
        int_cb.callBack(int_cb.opaque, fb);
    }

#ifdef H264E_DUMP_DATA_TO_FILE
    hal_h264e_vpu_dump_mpp_reg_out(ctx);
    hal_h264e_vpu_dump_mpp_strm_out(ctx, ctx->enc_task.output);
#endif
    //hal_h264e_vpu_dump_mpp_strm_out(ctx, NULL);

    h264e_hal_debug_leave();

    return MPP_OK;
}

MPP_RET hal_h264e_vpu_reset(void *hal)
{
    (void)hal;
    h264e_hal_debug_enter();

    h264e_hal_debug_leave();
    return MPP_OK;
}

MPP_RET hal_h264e_vpu_flush(void *hal)
{
    (void)hal;
    h264e_hal_debug_enter();

    h264e_hal_debug_leave();
    return MPP_OK;
}

MPP_RET hal_h264e_vpu_control(void *hal, RK_S32 cmd_type, void *param)
{
    h264e_hal_context *ctx = (h264e_hal_context *)hal;
    h264e_hal_debug_enter();

    h264e_hal_log_detail("hal_h264e_vpu_control cmd 0x%x, info %p", cmd_type, param);
    switch (cmd_type) {
    case MPP_ENC_SET_EXTRA_INFO: {
        hal_h264e_vpu_set_extra_info(ctx, param);
        break;
    }
    case MPP_ENC_GET_EXTRA_INFO: {
        MppPacket  pkt      = ctx->packeted_param;
        MppPacket *pkt_out  = (MppPacket *)param;

        h264e_hal_vpu_extra_info *src = (h264e_hal_vpu_extra_info *)ctx->extra_info;
        h264e_hal_vpu_stream *sps_stream = &src->sps_stream;
        h264e_hal_vpu_stream *pps_stream = &src->pps_stream;

        size_t offset = 0;

        mpp_packet_write(pkt, offset, sps_stream->buffer, sps_stream->byte_cnt);
        offset += sps_stream->byte_cnt;

        mpp_packet_write(pkt, offset, pps_stream->buffer, pps_stream->byte_cnt);
        offset += pps_stream->byte_cnt;

        mpp_packet_set_length(pkt, offset);

        *pkt_out = pkt;
#ifdef H264E_DUMP_DATA_TO_FILE
        hal_h264e_vpu_dump_mpp_strm_out_header(ctx, pkt);
#endif
        break;
    }
    case MPP_ENC_SET_SEI_CFG: {
        ctx->sei_mode = *((MppEncSeiMode *)param);
        break;
    }
    default : {
        mpp_err("unrecognizable cmd type %d", cmd_type);
    } break;
    }

    h264e_hal_debug_leave();
    return MPP_OK;
}

